{"version":3,"file":"rx-storage-instance-memory.js","names":["_rxjs","require","_customIndex","_rxSchemaHelper","_rxStorageHelper","_index","_binarySearchBounds","_memoryHelper","_memoryIndexes","_rxQueryHelper","OPEN_MEMORY_INSTANCES","exports","Set","RxStorageInstanceMemory","storage","databaseName","collectionName","schema","internals","options","settings","closed","categorizedByWriteInput","WeakMap","add","primaryPath","getPrimaryFieldOfPrimaryKey","primaryKey","_proto","prototype","bulkWrite","documentWrites","context","ensurePersistence","ensureNotRemoved","documentsById","documents","categorized","categorizeBulkWriteRows","error","errors","success","Array","bulkInsertDocs","length","i","writeRow","doc","document","bulkUpdateDocs","push","set","ensurePersistenceTask","ensurePersistenceIdlePromise","requestIdlePromiseNoQueue","then","undefined","eventBulk","events","lastState","ensureNotFalsy","newestRow","checkpoint","id","lwt","_meta","endTime","now","PROMISE_RESOLVE_TRUE","changes$","next","ret","Promise","resolve","stateByIndex","Object","values","byIndex","docId","putWriteRowToState","get","attachments","attachmentsMap","attachmentsAdd","forEach","attachment","attachmentMapKey","documentId","attachmentId","writeData","attachmentData","digest","attachmentsUpdate","attachmentsRemove","delete","findDocumentsById","docIds","withDeleted","size","docInDb","_deleted","query","preparedQuery","queryPlan","skip","limit","Infinity","skipPlusLimit","queryMatcher","selectorSatisfiedByIndex","getQueryMatcher","queryPlanFields","index","mustManuallyResort","sortSatisfiedByIndex","lowerBound","startKeys","lowerBoundString","getStartIndexStringFromLowerBound","upperBound","endKeys","upperBoundString","getStartIndexStringFromUpperBound","indexName","getMemoryIndexName","Error","docsWithIndex","indexOfLower","inclusiveStart","boundGE","boundGT","indexString","compareDocsWithIndex","indexOfUpper","inclusiveEnd","boundLE","boundLT","rows","done","currentRow","currentDoc","sortComparator","getSortComparator","sort","slice","count","result","mode","cleanup","minimumDeletedTime","maxDeletionTime","removeDocFromState","getAttachmentData","key","data","changeStream","asObservable","remove","removed","collectionStates","getMemoryCollectionKey","version","close","PROMISE_RESOLVE_VOID","refCount","conflictResultionTasks","conflictResultionTasks$","resolveConflictResultionTask","_taskSolution","createMemoryStorageInstance","params","collectionKey","randomCouchString","Map","Subject","addIndexesToInternalsState","devMode","deepEqual","instance"],"sources":["../../../../src/plugins/storage-memory/rx-storage-instance-memory.ts"],"sourcesContent":["import {\n    Observable,\n    Subject\n} from 'rxjs';\nimport {\n    getStartIndexStringFromLowerBound,\n    getStartIndexStringFromUpperBound\n} from '../../custom-index.ts';\nimport { getPrimaryFieldOfPrimaryKey } from '../../rx-schema-helper.ts';\nimport {\n    categorizeBulkWriteRows\n} from '../../rx-storage-helper.ts';\nimport type {\n    BulkWriteRow,\n    CategorizeBulkWriteRowsOutput,\n    EventBulk,\n    PreparedQuery,\n    QueryMatcher,\n    RxConflictResultionTask,\n    RxConflictResultionTaskSolution,\n    RxDocumentData,\n    RxJsonSchema,\n    RxStorageBulkWriteResponse,\n    RxStorageChangeEvent,\n    RxStorageCountResult,\n    RxStorageDefaultCheckpoint,\n    RxStorageInstance,\n    RxStorageInstanceCreationParams,\n    RxStorageQueryResult,\n    StringKeys\n} from '../../types/index.d.ts';\nimport {\n    deepEqual,\n    ensureNotFalsy,\n    now,\n    PROMISE_RESOLVE_TRUE,\n    PROMISE_RESOLVE_VOID,\n    randomCouchString,\n    requestIdlePromiseNoQueue\n} from '../../plugins/utils/index.ts';\nimport {\n    boundGE,\n    boundGT,\n    boundLE,\n    boundLT\n} from './binary-search-bounds.ts';\nimport {\n    attachmentMapKey,\n    compareDocsWithIndex,\n    ensureNotRemoved,\n    getMemoryCollectionKey,\n    putWriteRowToState,\n    removeDocFromState\n} from './memory-helper.ts';\nimport {\n    addIndexesToInternalsState,\n    getMemoryIndexName\n} from './memory-indexes.ts';\nimport type {\n    MemoryStorageInternals,\n    RxStorageMemory,\n    RxStorageMemoryInstanceCreationOptions,\n    RxStorageMemorySettings\n} from './memory-types.ts';\nimport { getQueryMatcher, getSortComparator } from '../../rx-query-helper.ts';\n\n/**\n * Used in tests to ensure everything\n * is closed correctly\n */\nexport const OPEN_MEMORY_INSTANCES = new Set<RxStorageInstanceMemory<any>>();\n\nexport class RxStorageInstanceMemory<RxDocType> implements RxStorageInstance<\n    RxDocType,\n    MemoryStorageInternals<RxDocType>,\n    RxStorageMemoryInstanceCreationOptions,\n    RxStorageDefaultCheckpoint\n> {\n\n    public readonly primaryPath: StringKeys<RxDocumentData<RxDocType>>;\n    public closed = false;\n\n    /**\n     * Used by some plugins and storage wrappers\n     * to find out details about the internals of a write operation.\n     * For example if you want to know which documents really have been replaced\n     * or newly inserted.\n     */\n    public categorizedByWriteInput = new WeakMap<BulkWriteRow<RxDocType>[], CategorizeBulkWriteRowsOutput<RxDocType>>();\n\n    constructor(\n        public readonly storage: RxStorageMemory,\n        public readonly databaseName: string,\n        public readonly collectionName: string,\n        public readonly schema: Readonly<RxJsonSchema<RxDocumentData<RxDocType>>>,\n        public readonly internals: MemoryStorageInternals<RxDocType>,\n        public readonly options: Readonly<RxStorageMemoryInstanceCreationOptions>,\n        public readonly settings: RxStorageMemorySettings\n    ) {\n        OPEN_MEMORY_INSTANCES.add(this);\n        this.primaryPath = getPrimaryFieldOfPrimaryKey(this.schema.primaryKey);\n    }\n\n    bulkWrite(\n        documentWrites: BulkWriteRow<RxDocType>[],\n        context: string\n    ): Promise<RxStorageBulkWriteResponse<RxDocType>> {\n        this.ensurePersistence();\n        ensureNotRemoved(this);\n        const internals = this.internals;\n        const documentsById = this.internals.documents;\n        const primaryPath = this.primaryPath;\n\n        const categorized = categorizeBulkWriteRows<RxDocType>(\n            this,\n            primaryPath as any,\n            documentsById,\n            documentWrites,\n            context\n        );\n        const error = categorized.errors;\n        const success: RxDocumentData<RxDocType>[] = new Array(categorized.bulkInsertDocs.length);\n        const bulkInsertDocs = categorized.bulkInsertDocs;\n        for (let i = 0; i < bulkInsertDocs.length; ++i) {\n            const writeRow = bulkInsertDocs[i];\n            const doc = writeRow.document;\n            success[i] = doc;\n        }\n        const bulkUpdateDocs = categorized.bulkUpdateDocs;\n        for (let i = 0; i < bulkUpdateDocs.length; ++i) {\n            const writeRow = bulkUpdateDocs[i];\n            const doc = writeRow.document;\n            success.push(doc);\n        }\n\n        this.categorizedByWriteInput.set(documentWrites, categorized);\n        this.internals.ensurePersistenceTask = categorized;\n        if (!this.internals.ensurePersistenceIdlePromise) {\n            this.internals.ensurePersistenceIdlePromise = requestIdlePromiseNoQueue().then(() => {\n                this.internals.ensurePersistenceIdlePromise = undefined;\n                this.ensurePersistence();\n            });\n        }\n\n        /**\n         * Important: The events must be emitted AFTER the persistence\n         * task has been added.\n         */\n        if (categorized.eventBulk.events.length > 0) {\n            const lastState = ensureNotFalsy(categorized.newestRow).document;\n            categorized.eventBulk.checkpoint = {\n                id: lastState[primaryPath],\n                lwt: lastState._meta.lwt\n            };\n            categorized.eventBulk.endTime = now();\n            PROMISE_RESOLVE_TRUE.then(() => {\n                internals.changes$.next(categorized.eventBulk);\n            });\n        }\n\n        const ret = Promise.resolve({ success, error });\n        return ret;\n    }\n\n    /**\n     * Instead of directly inserting the documents into all indexes,\n     * we do it lazy in the background. This gives the application time\n     * to directly work with the write-result and to do stuff like rendering DOM\n     * notes and processing RxDB queries.\n     * Then in some later time, or just before the next read/write,\n     * it is ensured that the indexes have been written.\n     */\n    public ensurePersistence() {\n        if (\n            !this.internals.ensurePersistenceTask\n        ) {\n            return;\n        }\n        const internals = this.internals;\n        const documentsById = this.internals.documents;\n        const primaryPath = this.primaryPath;\n\n        const categorized = this.internals.ensurePersistenceTask;\n        this.internals.ensurePersistenceTask = undefined;\n\n        /**\n         * Do inserts/updates\n         */\n        const stateByIndex = Object.values(this.internals.byIndex);\n\n        const bulkInsertDocs = categorized.bulkInsertDocs;\n        for (let i = 0; i < bulkInsertDocs.length; ++i) {\n            const writeRow = bulkInsertDocs[i];\n            const doc = writeRow.document;\n            const docId = doc[primaryPath];\n            putWriteRowToState(\n                docId as any,\n                internals,\n                stateByIndex,\n                writeRow,\n                undefined\n            );\n        }\n\n        const bulkUpdateDocs = categorized.bulkUpdateDocs;\n        for (let i = 0; i < bulkUpdateDocs.length; ++i) {\n            const writeRow = bulkUpdateDocs[i];\n            const doc = writeRow.document;\n            const docId = doc[primaryPath];\n            putWriteRowToState(\n                docId as any,\n                internals,\n                stateByIndex,\n                writeRow,\n                documentsById.get(docId as any)\n            );\n        }\n\n        /**\n         * Handle attachments\n         */\n        if (this.schema.attachments) {\n            const attachmentsMap = internals.attachments;\n            categorized.attachmentsAdd.forEach(attachment => {\n                attachmentsMap.set(\n                    attachmentMapKey(attachment.documentId, attachment.attachmentId),\n                    {\n                        writeData: attachment.attachmentData,\n                        digest: attachment.digest\n                    }\n                );\n            });\n            if (this.schema.attachments) {\n                categorized.attachmentsUpdate.forEach(attachment => {\n                    attachmentsMap.set(\n                        attachmentMapKey(attachment.documentId, attachment.attachmentId),\n                        {\n                            writeData: attachment.attachmentData,\n                            digest: attachment.digest\n                        }\n                    );\n                });\n                categorized.attachmentsRemove.forEach(attachment => {\n                    attachmentsMap.delete(\n                        attachmentMapKey(attachment.documentId, attachment.attachmentId)\n                    );\n                });\n            }\n        }\n    }\n\n    findDocumentsById(\n        docIds: string[],\n        withDeleted: boolean\n    ): Promise<RxDocumentData<RxDocType>[]> {\n        this.ensurePersistence();\n        const documentsById = this.internals.documents;\n        const ret: RxDocumentData<RxDocType>[] = [];\n        if (documentsById.size === 0) {\n            return Promise.resolve(ret);\n        }\n        for (let i = 0; i < docIds.length; ++i) {\n            const docId = docIds[i];\n            const docInDb = documentsById.get(docId);\n            if (\n                docInDb &&\n                (\n                    !docInDb._deleted ||\n                    withDeleted\n                )\n            ) {\n                ret.push(docInDb);\n            }\n        }\n        return Promise.resolve(ret);\n    }\n\n    query(\n        preparedQuery: PreparedQuery<RxDocType>\n    ): Promise<RxStorageQueryResult<RxDocType>> {\n        this.ensurePersistence();\n\n        const queryPlan = preparedQuery.queryPlan;\n        const query = preparedQuery.query;\n\n        const skip = query.skip ? query.skip : 0;\n        const limit = query.limit ? query.limit : Infinity;\n        const skipPlusLimit = skip + limit;\n\n        let queryMatcher: QueryMatcher<RxDocumentData<RxDocType>> | false = false;\n        if (!queryPlan.selectorSatisfiedByIndex) {\n            queryMatcher = getQueryMatcher(\n                this.schema,\n                preparedQuery.query\n            );\n        }\n\n        const queryPlanFields: string[] = queryPlan.index;\n        const mustManuallyResort = !queryPlan.sortSatisfiedByIndex;\n        const index: string[] | undefined = queryPlanFields;\n        const lowerBound: any[] = queryPlan.startKeys;\n        const lowerBoundString = getStartIndexStringFromLowerBound(\n            this.schema,\n            index,\n            lowerBound\n        );\n\n        let upperBound: any[] = queryPlan.endKeys;\n        upperBound = upperBound;\n        const upperBoundString = getStartIndexStringFromUpperBound(\n            this.schema,\n            index,\n            upperBound\n        );\n        const indexName = getMemoryIndexName(index);\n\n        if (!this.internals.byIndex[indexName]) {\n            throw new Error('index does not exist ' + indexName);\n        }\n        const docsWithIndex = this.internals.byIndex[indexName].docsWithIndex;\n\n\n\n        let indexOfLower = (queryPlan.inclusiveStart ? boundGE : boundGT)(\n            docsWithIndex,\n            {\n                indexString: lowerBoundString\n            } as any,\n            compareDocsWithIndex\n        );\n\n        const indexOfUpper = (queryPlan.inclusiveEnd ? boundLE : boundLT)(\n            docsWithIndex,\n            {\n                indexString: upperBoundString\n            } as any,\n            compareDocsWithIndex\n        );\n\n        let rows: RxDocumentData<RxDocType>[] = [];\n        let done = false;\n        while (!done) {\n            const currentRow = docsWithIndex[indexOfLower];\n            if (\n                !currentRow ||\n                indexOfLower > indexOfUpper\n            ) {\n                break;\n            }\n            const currentDoc = currentRow.doc;\n\n            if (!queryMatcher || queryMatcher(currentDoc)) {\n                rows.push(currentDoc);\n            }\n\n            if (\n                (rows.length >= skipPlusLimit && !mustManuallyResort)\n            ) {\n                done = true;\n            }\n\n            indexOfLower++;\n        }\n\n        if (mustManuallyResort) {\n            const sortComparator = getSortComparator(this.schema, preparedQuery.query);\n            rows = rows.sort(sortComparator);\n        }\n\n        // apply skip and limit boundaries.\n        rows = rows.slice(skip, skipPlusLimit);\n        return Promise.resolve({\n            documents: rows\n        });\n    }\n\n    async count(\n        preparedQuery: PreparedQuery<RxDocType>\n    ): Promise<RxStorageCountResult> {\n        this.ensurePersistence();\n        const result = await this.query(preparedQuery);\n        return {\n            count: result.documents.length,\n            mode: 'fast'\n        };\n    }\n\n    cleanup(minimumDeletedTime: number): Promise<boolean> {\n        this.ensurePersistence();\n        const maxDeletionTime = now() - minimumDeletedTime;\n        const index = ['_deleted', '_meta.lwt', this.primaryPath as any];\n        const indexName = getMemoryIndexName(index);\n        const docsWithIndex = this.internals.byIndex[indexName].docsWithIndex;\n\n        const lowerBoundString = getStartIndexStringFromLowerBound(\n            this.schema,\n            index,\n            [\n                true,\n                0,\n                ''\n            ]\n        );\n\n        let indexOfLower = boundGT(\n            docsWithIndex,\n            {\n                indexString: lowerBoundString\n            } as any,\n            compareDocsWithIndex\n        );\n\n        let done = false;\n        while (!done) {\n            const currentDoc = docsWithIndex[indexOfLower];\n            if (!currentDoc || currentDoc.doc._meta.lwt > maxDeletionTime) {\n                done = true;\n            } else {\n                removeDocFromState(\n                    this.primaryPath as any,\n                    this.schema,\n                    this.internals,\n                    currentDoc.doc\n                );\n                indexOfLower++;\n            }\n        }\n        return PROMISE_RESOLVE_TRUE;\n    }\n\n    getAttachmentData(\n        documentId: string,\n        attachmentId: string,\n        digest: string\n    ): Promise<string> {\n        this.ensurePersistence();\n        ensureNotRemoved(this);\n        const key = attachmentMapKey(documentId, attachmentId);\n        const data = this.internals.attachments.get(key);\n\n        if (\n            !digest ||\n            !data ||\n            data.digest !== digest\n        ) {\n            throw new Error('attachment does not exist: ' + key);\n        }\n        return Promise.resolve(data.writeData.data);\n    }\n\n    changeStream(): Observable<EventBulk<RxStorageChangeEvent<RxDocumentData<RxDocType>>, RxStorageDefaultCheckpoint>> {\n        ensureNotRemoved(this);\n        return this.internals.changes$.asObservable();\n    }\n\n    async remove(): Promise<void> {\n        if (this.closed) {\n            throw new Error('closed');\n        }\n        this.ensurePersistence();\n        ensureNotRemoved(this);\n\n        this.internals.removed = true;\n        this.storage.collectionStates.delete(\n            getMemoryCollectionKey(\n                this.databaseName,\n                this.collectionName,\n                this.schema.version\n            )\n        );\n        await this.close();\n    }\n\n    close(): Promise<void> {\n        OPEN_MEMORY_INSTANCES.delete(this);\n\n        this.ensurePersistence();\n        if (this.closed) {\n            return PROMISE_RESOLVE_VOID;\n        }\n        this.closed = true;\n\n        this.internals.refCount = this.internals.refCount - 1;\n        return PROMISE_RESOLVE_VOID;\n    }\n\n    conflictResultionTasks(): Observable<RxConflictResultionTask<RxDocType>> {\n        return this.internals.conflictResultionTasks$.asObservable();\n    }\n    resolveConflictResultionTask(_taskSolution: RxConflictResultionTaskSolution<RxDocType>): Promise<void> {\n        return PROMISE_RESOLVE_VOID;\n    }\n}\n\nexport function createMemoryStorageInstance<RxDocType>(\n    storage: RxStorageMemory,\n    params: RxStorageInstanceCreationParams<RxDocType, RxStorageMemoryInstanceCreationOptions>,\n    settings: RxStorageMemorySettings\n): Promise<RxStorageInstanceMemory<RxDocType>> {\n    const collectionKey = getMemoryCollectionKey(\n        params.databaseName,\n        params.collectionName,\n        params.schema.version\n    );\n\n    let internals = storage.collectionStates.get(collectionKey);\n    if (!internals) {\n        internals = {\n            id: randomCouchString(5),\n            schema: params.schema,\n            removed: false,\n            refCount: 1,\n            documents: new Map(),\n            attachments: params.schema.attachments ? new Map() : undefined as any,\n            byIndex: {},\n            conflictResultionTasks$: new Subject(),\n            changes$: new Subject()\n        };\n        addIndexesToInternalsState(internals, params.schema);\n        storage.collectionStates.set(collectionKey, internals);\n    } else {\n        /**\n         * Ensure that the storage was not already\n         * created with a different schema.\n         * This is very important because if this check\n         * does not exist here, we have hard-to-debug problems\n         * downstream.\n         */\n        if (\n            params.devMode &&\n            !deepEqual(internals.schema, params.schema)\n        ) {\n            throw new Error('storage was already created with a different schema');\n        }\n        internals.refCount = internals.refCount + 1;\n    }\n\n    const instance = new RxStorageInstanceMemory(\n        storage,\n        params.databaseName,\n        params.collectionName,\n        params.schema,\n        internals,\n        params.options,\n        settings\n    );\n    return Promise.resolve(instance);\n}\n"],"mappings":"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","ignoreList":[]}