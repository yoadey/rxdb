{"version":3,"file":"index.js","names":["BehaviorSubject","combineLatest","filter","firstValueFrom","mergeMap","Subject","getPrimaryFieldOfPrimaryKey","clone","ensureNotFalsy","flatClone","PROMISE_RESOLVE_VOID","getCheckpointKey","startReplicationDownstream","docStateToWriteDoc","getUnderlyingPersistentStorage","writeDocToDocState","startReplicationUpstream","fillWriteDataForAttachmentsChange","getChangedDocumentsSince","replicateRxStorageInstance","input","forkInstance","metaInstance","checkpointKeyPromise","state","primaryPath","schema","primaryKey","hasAttachments","attachments","checkpointKey","downstreamBulkWriteFlag","then","events","canceled","active","down","up","processed","resolvedConflicts","error","stats","addNewTask","downstreamProcessChanges","downstreamResyncOnce","masterChangeStreamEmit","persistFromMaster","forkChangeStreamEmit","persistToMaster","persistToMasterConflictWrites","persistToMasterHadConflicts","processTasks","upstreamInitialSync","firstSyncDone","streamQueue","checkpointQueue","lastCheckpointDoc","awaitRxStorageReplicationFirstInSync","pipe","v","awaitRxStorageReplicationInSync","replicationState","Promise","all","awaitRxStorageReplicationIdle","rxStorageInstanceToReplicationHandler","instance","conflictHandler","databaseInstanceToken","keepMeta","replicationHandler","masterChangeStream$","changeStream","eventBulk","ret","checkpoint","documents","map","event","docData","documentData","undefined","masterChangesSince","batchSize","result","length","plainDocumentData","masterWrite","rows","rowById","forEach","row","docId","newDocumentState","ids","Object","keys","masterDocsStateList","findDocumentsById","masterDocsState","Map","doc","set","conflicts","writeRows","entries","id","masterState","get","push","document","assumedMasterState","realMasterState","isEqual","previous","bulkWrite","err","status","Error","documentInDb","cancelRxStorageReplication","next","complete"],"sources":["../../../src/replication-protocol/index.ts"],"sourcesContent":["/**\n * These files contain the replication protocol.\n * It can be used to replicated RxStorageInstances or RxCollections\n * or even to do a client(s)-server replication.\n */\n\n\nimport {\n    BehaviorSubject,\n    combineLatest,\n    filter,\n    firstValueFrom,\n    mergeMap,\n    Subject\n} from 'rxjs';\nimport {\n    getPrimaryFieldOfPrimaryKey\n} from '../rx-schema-helper.ts';\nimport type {\n    BulkWriteRow,\n    ById,\n    DocumentsWithCheckpoint,\n    RxConflictHandler,\n    RxDocumentData,\n    RxReplicationHandler,\n    RxReplicationWriteToMasterRow,\n    RxStorageInstance,\n    RxStorageInstanceReplicationInput,\n    RxStorageInstanceReplicationState,\n    WithDeleted\n} from '../types/index.d.ts';\nimport {\n    clone,\n    ensureNotFalsy,\n    flatClone,\n    PROMISE_RESOLVE_VOID\n} from '../plugins/utils/index.ts';\nimport {\n    getCheckpointKey\n} from './checkpoint.ts';\nimport { startReplicationDownstream } from './downstream.ts';\nimport { docStateToWriteDoc, getUnderlyingPersistentStorage, writeDocToDocState } from './helper.ts';\nimport { startReplicationUpstream } from './upstream.ts';\nimport { fillWriteDataForAttachmentsChange } from '../plugins/attachments/index.ts';\nimport { getChangedDocumentsSince } from '../rx-storage-helper.ts';\n\n\nexport * from './checkpoint.ts';\nexport * from './downstream.ts';\nexport * from './upstream.ts';\nexport * from './meta-instance.ts';\nexport * from './conflicts.ts';\nexport * from './helper.ts';\n\n\nexport function replicateRxStorageInstance<RxDocType>(\n    input: RxStorageInstanceReplicationInput<RxDocType>\n): RxStorageInstanceReplicationState<RxDocType> {\n    input = flatClone(input);\n    input.forkInstance = getUnderlyingPersistentStorage(input.forkInstance);\n    input.metaInstance = getUnderlyingPersistentStorage(input.metaInstance);\n    const checkpointKeyPromise = getCheckpointKey(input);\n    const state: RxStorageInstanceReplicationState<RxDocType> = {\n        primaryPath: getPrimaryFieldOfPrimaryKey(input.forkInstance.schema.primaryKey),\n        hasAttachments: !!input.forkInstance.schema.attachments,\n        input,\n        checkpointKey: checkpointKeyPromise,\n        downstreamBulkWriteFlag: checkpointKeyPromise.then(checkpointKey => 'replication-downstream-' + checkpointKey),\n        events: {\n            canceled: new BehaviorSubject<boolean>(false),\n            active: {\n                down: new BehaviorSubject<boolean>(true),\n                up: new BehaviorSubject<boolean>(true)\n            },\n            processed: {\n                down: new Subject(),\n                up: new Subject()\n            },\n            resolvedConflicts: new Subject(),\n            error: new Subject()\n        },\n        stats: {\n            down: {\n                addNewTask: 0,\n                downstreamProcessChanges: 0,\n                downstreamResyncOnce: 0,\n                masterChangeStreamEmit: 0,\n                persistFromMaster: 0\n            },\n            up: {\n                forkChangeStreamEmit: 0,\n                persistToMaster: 0,\n                persistToMasterConflictWrites: 0,\n                persistToMasterHadConflicts: 0,\n                processTasks: 0,\n                upstreamInitialSync: 0\n            }\n        },\n        firstSyncDone: {\n            down: new BehaviorSubject<boolean>(false),\n            up: new BehaviorSubject<boolean>(false)\n        },\n        streamQueue: {\n            down: PROMISE_RESOLVE_VOID,\n            up: PROMISE_RESOLVE_VOID\n        },\n        checkpointQueue: PROMISE_RESOLVE_VOID,\n        lastCheckpointDoc: {}\n    };\n\n    startReplicationDownstream(state);\n    startReplicationUpstream(state);\n    return state;\n}\n\nexport function awaitRxStorageReplicationFirstInSync(\n    state: RxStorageInstanceReplicationState<any>\n): Promise<void> {\n    return firstValueFrom(\n        combineLatest([\n            state.firstSyncDone.down.pipe(\n                filter(v => !!v)\n            ),\n            state.firstSyncDone.up.pipe(\n                filter(v => !!v)\n            )\n        ])\n    ).then(() => { });\n}\n\nexport function awaitRxStorageReplicationInSync(\n    replicationState: RxStorageInstanceReplicationState<any>\n) {\n    return Promise.all([\n        replicationState.streamQueue.up,\n        replicationState.streamQueue.down,\n        replicationState.checkpointQueue\n    ]);\n}\n\n\nexport async function awaitRxStorageReplicationIdle(\n    state: RxStorageInstanceReplicationState<any>\n) {\n    await awaitRxStorageReplicationFirstInSync(state);\n    while (true) {\n        const { down, up } = state.streamQueue;\n        await Promise.all([\n            up,\n            down\n        ]);\n        /**\n         * If the Promises have not been reassigned\n         * after awaiting them, we know that the replication\n         * is in idle state at this point in time.\n         */\n        if (\n            down === state.streamQueue.down &&\n            up === state.streamQueue.up\n        ) {\n            return;\n        }\n    }\n}\n\n\nexport function rxStorageInstanceToReplicationHandler<RxDocType, MasterCheckpointType>(\n    instance: RxStorageInstance<RxDocType, any, any, MasterCheckpointType>,\n    conflictHandler: RxConflictHandler<RxDocType>,\n    databaseInstanceToken: string,\n    /**\n     * If set to true,\n     * the _meta.lwt from the pushed documents is kept.\n     * (Used in the migration to ensure checkpoints are still valid)\n     */\n    keepMeta: boolean = false\n): RxReplicationHandler<RxDocType, MasterCheckpointType> {\n    instance = getUnderlyingPersistentStorage(instance);\n\n    const hasAttachments = !!instance.schema.attachments;\n    const primaryPath = getPrimaryFieldOfPrimaryKey(instance.schema.primaryKey);\n    const replicationHandler: RxReplicationHandler<RxDocType, MasterCheckpointType> = {\n        masterChangeStream$: instance.changeStream().pipe(\n            mergeMap(async (eventBulk) => {\n                const ret: DocumentsWithCheckpoint<RxDocType, MasterCheckpointType> = {\n                    checkpoint: eventBulk.checkpoint,\n                    documents: await Promise.all(\n                        eventBulk.events.map(async (event) => {\n                            let docData = writeDocToDocState(event.documentData, hasAttachments, keepMeta);\n                            if (hasAttachments) {\n                                docData = await fillWriteDataForAttachmentsChange(\n                                    primaryPath,\n                                    instance,\n                                    clone(docData),\n                                    /**\n                                     * Notice that the master never knows\n                                     * the client state of the document.\n                                     * Therefore we always send all attachments data.\n                                     */\n                                    undefined\n                                );\n                            }\n\n                            return docData;\n                        })\n                    )\n                };\n                return ret;\n            })\n        ),\n        masterChangesSince(\n            checkpoint,\n            batchSize\n        ) {\n            return getChangedDocumentsSince(\n                instance,\n                batchSize,\n                checkpoint\n            ).then(async (result) => {\n                return {\n                    checkpoint: result.documents.length > 0 ? result.checkpoint : checkpoint,\n                    documents: await Promise.all(\n                        result.documents.map(async (plainDocumentData) => {\n                            let docData = writeDocToDocState(plainDocumentData, hasAttachments, keepMeta);\n                            if (hasAttachments) {\n                                docData = await fillWriteDataForAttachmentsChange(\n                                    primaryPath,\n                                    instance,\n                                    clone(docData),\n                                    /**\n                                     * Notice the the master never knows\n                                     * the client state of the document.\n                                     * Therefore we always send all attachments data.\n                                     */\n                                    undefined\n                                );\n                            }\n                            return docData;\n                        })\n                    )\n                };\n            });\n        },\n        async masterWrite(\n            rows\n        ) {\n            const rowById: ById<RxReplicationWriteToMasterRow<RxDocType>> = {};\n            rows.forEach(row => {\n                const docId: string = (row.newDocumentState as any)[primaryPath];\n                rowById[docId] = row;\n            });\n            const ids = Object.keys(rowById);\n\n            const masterDocsStateList = await instance.findDocumentsById(\n                ids,\n                true\n            );\n            const masterDocsState = new Map<string, RxDocumentData<RxDocType>>();\n            masterDocsStateList.forEach(doc => masterDocsState.set((doc as any)[primaryPath], doc));\n            const conflicts: WithDeleted<RxDocType>[] = [];\n            const writeRows: BulkWriteRow<RxDocType>[] = [];\n            await Promise.all(\n                Object.entries(rowById)\n                    .map(async ([id, row]) => {\n                        const masterState = masterDocsState.get(id);\n                        if (!masterState) {\n                            writeRows.push({\n                                document: docStateToWriteDoc(databaseInstanceToken, hasAttachments, keepMeta, row.newDocumentState)\n                            });\n                        } else if (\n                            masterState &&\n                            !row.assumedMasterState\n                        ) {\n                            conflicts.push(writeDocToDocState(masterState, hasAttachments, keepMeta));\n                        } else if (\n                            (await conflictHandler({\n                                realMasterState: writeDocToDocState(masterState, hasAttachments, keepMeta),\n                                newDocumentState: ensureNotFalsy(row.assumedMasterState)\n                            }, 'rxStorageInstanceToReplicationHandler-masterWrite')).isEqual === true\n                        ) {\n                            writeRows.push({\n                                previous: masterState,\n                                document: docStateToWriteDoc(databaseInstanceToken, hasAttachments, keepMeta, row.newDocumentState, masterState)\n                            });\n                        } else {\n                            conflicts.push(writeDocToDocState(masterState, hasAttachments, keepMeta));\n                        }\n                    })\n            );\n\n            if (writeRows.length > 0) {\n                const result = await instance.bulkWrite(\n                    writeRows,\n                    'replication-master-write'\n                );\n\n                result.error.forEach(err => {\n                    if (err.status !== 409) {\n                        throw new Error('non conflict error');\n                    } else {\n                        conflicts.push(\n                            writeDocToDocState(ensureNotFalsy(err.documentInDb), hasAttachments, keepMeta)\n                        );\n                    }\n                });\n            }\n            return conflicts;\n        }\n    };\n\n    return replicationHandler;\n}\n\n\nexport async function cancelRxStorageReplication(\n    replicationState: RxStorageInstanceReplicationState<any>\n) {\n    replicationState.events.canceled.next(true);\n    replicationState.events.active.up.complete();\n    replicationState.events.active.down.complete();\n    replicationState.events.processed.up.complete();\n    replicationState.events.processed.down.complete();\n    replicationState.events.resolvedConflicts.complete();\n    replicationState.events.canceled.complete();\n    await replicationState.checkpointQueue;\n}\n"],"mappings":"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","ignoreList":[]}