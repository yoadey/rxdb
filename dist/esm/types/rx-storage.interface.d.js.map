{"version":3,"file":"rx-storage.interface.d.js","names":[],"sources":["../../../src/types/rx-storage.interface.d.ts"],"sourcesContent":["import type {\n    BulkWriteRow,\n    EventBulk,\n    RxDocumentData,\n    RxStorageBulkWriteResponse,\n    RxStorageChangeEvent,\n    RxStorageCountResult,\n    RxStorageInstanceCreationParams,\n    RxStorageQueryResult\n} from './rx-storage.ts';\nimport type {\n    MangoQuerySelector,\n    MangoQuerySortPart,\n    RxConflictResultionTask,\n    RxConflictResultionTaskSolution,\n    RxJsonSchema,\n    RxQueryPlan\n} from './index.d.ts';\nimport type {\n    Observable\n} from 'rxjs';\n\n/**\n * RxStorage\n * This is an interface that abstracts the storage engine.\n * This allows us to use RxDB with different storage engines.\n *\n * @link https://rxdb.info/rx-storage.html\n * @link https://github.com/pubkey/rxdb/issues/1636\n */\n\n\n/**\n * A RxStorage is a module that acts\n * as a factory that can create multiple RxStorageInstance\n * objects.\n *\n * All data inputs and outputs of a StorageInstance must be plain json objects.\n * Do not use Map, Set or anything else that cannot be JSON.stringify-ed.\n * This will ensure that the storage can exchange data\n * when it is a WebWorker or a WASM process or data is send via BroadcastChannel.\n */\nexport interface RxStorage<Internals, InstanceCreationOptions> {\n    /**\n     * name of the storage engine\n     * used to detect if plugins do not work so we can throw proper errors.\n     */\n    readonly name: string;\n\n    /**\n     * RxDB version is part of the storage\n     * so we can have fallbacks and stuff when\n     * multiple storages with different version are in use\n     * like in the storage migration plugin.\n     */\n    readonly rxdbVersion: string;\n\n    /**\n     * Creates a storage instance\n     * that can contain the NoSQL documents of a collection.\n     */\n    createStorageInstance<RxDocType>(\n        params: RxStorageInstanceCreationParams<RxDocType, InstanceCreationOptions>\n    ): Promise<RxStorageInstance<RxDocType, Internals, InstanceCreationOptions>>;\n}\n\n\n/**\n * User provided mango queries will be filled up by RxDB via normalizeMangoQuery()\n * so we do not have to do many if-field-exist tests in the internals.\n */\nexport type FilledMangoQuery<RxDocType> = {\n    /**\n     * The selector is required here.\n     */\n    selector: MangoQuerySelector<RxDocumentData<RxDocType>>;\n\n    /**\n     * In contrast to the user-provided MangoQuery,\n     * the sorting is required here because\n     * RxDB has to ensure that the primary key is always\n     * part of the sort params.\n     */\n    sort: MangoQuerySortPart<RxDocumentData<RxDocType>>[];\n\n    /**\n     * In the normalized mango query,\n     * the index must always be a string[],\n     * never just a string.\n     * This makes it easier to use the query because\n     * we do not have to do an array check.\n     */\n    index?: string[];\n\n    /**\n     * Skip must be set which defaults to 0\n     */\n    skip: number;\n\n    limit?: number;\n};\n\n\n/**\n * Before sending a query to the storageInstance.query()\n * we run it through the query planner and do some normalization\n * stuff. Notice that the queryPlan is a hint for the storage and\n * it is not required to use it when running queries. Some storages\n * might use their own query planning instead.\n */\nexport type PreparedQuery<RxDocType> = {\n    // original query from the input\n    query: FilledMangoQuery<RxDocType>;\n    queryPlan: RxQueryPlan;\n};\n\nexport interface RxStorageInstance<\n    /**\n     * The type of the documents that can be stored in this instance.\n     * All documents in an instance must comply to the same schema.\n     * Also all documents are RxDocumentData with the meta properties like\n     * _deleted or _rev etc.\n     */\n    RxDocType,\n    Internals,\n    InstanceCreationOptions,\n    CheckpointType = any\n> {\n    readonly databaseName: string;\n    /**\n     * Returns the internal data that is used by the storage engine.\n     */\n    readonly internals: Readonly<Internals>;\n    readonly options: Readonly<InstanceCreationOptions>;\n    /**\n     * The schema that defines the documents that are stored in this instance.\n     * Notice that the schema must be enhanced with the meta properties like\n     * _meta, _rev and _deleted etc. which are added by fillWithDefaultSettings()\n     */\n    readonly schema: Readonly<RxJsonSchema<RxDocumentData<RxDocType>>>;\n    readonly collectionName: string;\n\n    /**\n     * (Optional) reference to the underlying persistent storage instance.\n     * If set, things like replication will run on that storageInstance instead of the parent.\n     * This is mostly used in things like the memory-synced storage where we want to\n     * run replications and migrations on the persistent storage instead of the in-memory storage.\n     *\n     * Having this is the least hacky option. The only other option would be to toggle all calls to the\n     * storageInstance by checking the givent context-string. But this would make it impossible\n     * to run a replication on the parentStorage itself.\n     */\n    readonly underlyingPersistentStorage?: RxStorageInstance<RxDocType, any, any, any>;\n\n    /**\n     * Writes multiple documents to the storage instance.\n     * The write for each single document is atomic, there\n     * is no transaction around all documents.\n     * The written documents must be the newest revision of that documents data.\n     * If the previous document is not the current newest revision, a conflict error\n     * must be returned.\n     * It must be possible that some document writes succeed\n     * and others error. We need this to have a similar behavior as most NoSQL databases.\n     */\n    bulkWrite(\n        documentWrites: BulkWriteRow<RxDocType>[],\n        /**\n         * Context will be used in all\n         * changeStream()-events that are emitted as a result\n         * of that bulkWrite() operation.\n         * Used in plugins so that we can detect that event X\n         * comes from operation Y.\n         */\n        context: string\n    ): Promise<RxStorageBulkWriteResponse<RxDocType>>;\n\n    /**\n     * Get Multiple documents by their primary value.\n     * This must also return deleted documents.\n     */\n    findDocumentsById(\n        /**\n         * List of primary values\n         * of the documents to find.\n         */\n        ids: string[],\n        /**\n         * If set to true, deleted documents will also be returned.\n         */\n        withDeleted: boolean\n\n    ): Promise<\n        /**\n         * For better performance, we return an array\n         * instead of an indexed object because most consumers\n         * of this anyway have to fill a Map() instance or\n         * even do only need the list at all.\n         */\n        RxDocumentData<RxDocType>[]\n    >;\n\n    /**\n     * Runs a NoSQL 'mango' query over the storage\n     * and returns the found documents data.\n     * Having all storage instances behave similar\n     * is likely the most difficult thing when creating a new\n     * rx-storage implementation.\n     */\n    query(\n        preparedQuery: PreparedQuery<RxDocType>\n    ): Promise<RxStorageQueryResult<RxDocType>>;\n\n    /**\n     * Returns the amount of non-deleted documents\n     * that match the given query.\n     * Sort, skip and limit of the query must be ignored!\n     */\n    count(\n        preparedQuery: PreparedQuery<RxDocType>\n    ): Promise<RxStorageCountResult>;\n\n    /**\n     * Returns the plain data of a single attachment.\n     */\n    getAttachmentData(\n        documentId: string,\n        attachmentId: string,\n        digest: string\n    ): Promise<string>;\n\n    /**\n     * Returns the current (not the old!) data of all documents that have been changed AFTER the given checkpoint.\n     * If the returned array does not reach the limit, it can be assumed that the \"end\" is reached, when paginating over the changes.\n     * Also returns a new checkpoint for each document which can be used to continue with the pagination from that change on.\n     * Must never return the same document multiple times in the same call operation.\n     * This is used by RxDB to known what has changed since X so these docs can be handled by the backup or the replication\n     * plugin.\n     *\n     * Important: This method is optional. If not defined,\n     * RxDB will manually run a query and use the last returned document\n     * for checkpointing. In  the future we might even remove this method completely\n     * and let RxDB do the work instead of the RxStorage.\n     */\n    getChangedDocumentsSince?(\n        limit: number,\n        /**\n         * The checkpoint from with to start\n         * when the events are sorted in time.\n         * If we want to start from the beginning,\n         * undefined is used as a checkpoint.\n         */\n        checkpoint?: CheckpointType\n    ): Promise<{\n        documents: RxDocumentData<RxDocType>[];\n        /**\n         * The checkpoint contains data so that another\n         * call to getChangedDocumentsSince() will continue\n         * from exactly the last document that was returned before.\n         */\n        checkpoint: CheckpointType;\n    }>;\n\n    /**\n     * Returns an ongoing stream\n     * of all changes that happen to the\n     * storage instance.\n     * Do not forget to unsubscribe.\n     *\n     * If the RxStorage support multi-instance,\n     * and the storage is persistent,\n     * then the emitted changes of one RxStorageInstance\n     * must be also emitted to other instances with the same databaseName+collectionName.\n     * See ./rx-storage-multiinstance.ts\n     */\n    changeStream(): Observable<EventBulk<RxStorageChangeEvent<RxDocType>, CheckpointType>>;\n\n    /**\n     * Runs a cleanup that removes all tompstones\n     * of documents that have _deleted set to true\n     * to free up disc space.\n     *\n     * Returns true if all cleanable documents have been removed.\n     * Returns false if there are more documents to be cleaned up,\n     * but not all have been purged because that would block the storage for too long.\n     */\n    cleanup(\n        /**\n         * The minimum time in milliseconds\n         * of how long a document must have been deleted\n         * until it is purged by the cleanup.\n         */\n        minimumDeletedTime: number\n    ): Promise<\n        /**\n         * True if all docs cleaned up,\n         * false if there are more docs to clean up\n         */\n        boolean\n    >;\n\n    /**\n     * Closes the storage instance so it cannot be used\n     * anymore and should clear all memory.\n     * The returned promise must resolve when everything is cleaned up.\n     */\n    close(): Promise<void>;\n\n    /**\n     * Remove the database and\n     * deletes all of its data.\n     */\n    remove(): Promise<void>;\n\n    /**\n     * Instead of passing the conflict-resolver function\n     * into the storage, we have to work with an observable that emits tasks\n     * and a resolver that takes resolved tasks.\n     * This is needed because the RxStorageInstance might run inside of a Worker\n     * other JavaScript process, so we cannot pass plain code.\n     */\n    conflictResultionTasks(): Observable<RxConflictResultionTask<RxDocType>>;\n    resolveConflictResultionTask(taskSolution: RxConflictResultionTaskSolution<RxDocType>): Promise<void>;\n}\n"],"mappings":"","ignoreList":[]}