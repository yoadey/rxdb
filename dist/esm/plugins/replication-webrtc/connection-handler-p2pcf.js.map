{"version":3,"file":"connection-handler-p2pcf.js","names":[],"sources":["../../../../src/plugins/replication-webrtc/connection-handler-p2pcf.ts"],"sourcesContent":["// import { Subject } from 'rxjs';\n// import { PROMISE_RESOLVE_VOID, randomCouchString } from '../../util';\n// import type {\n//     P2PConnectionHandler,\n//     P2PConnectionHandlerCreator,\n//     P2PMessage,\n//     P2PPeer,\n//     PeerWithMessage,\n//     PeerWithResponse\n// } from './p2p-types';\n\n// import P2PCF from 'p2pcf';\n\n// /**\n//  * Returns a connection handler that uses the Cloudflare worker signaling server\n//  * @link https://github.com/gfodor/p2pcf\n//  */\n// export function getConnectionHandlerP2PCF(\n//     p2pCFOptions: {\n//         workerUrl?: string\n//     } = {}\n// ): P2PConnectionHandlerCreator {\n// //    const P2PCF = require('p2pcf');\n\n//     const creator: P2PConnectionHandlerCreator = (options) => {\n//         const clientId = randomCouchString(10);\n//         const p2p2 = new P2PCF(clientId, options.topic, p2pCFOptions);\n\n//         const connect$ = new Subject<P2PPeer>();\n//         p2p2.on('peerconnect', (peer) => connect$.next(peer as any));\n\n//         const disconnect$ = new Subject<P2PPeer>();\n//         p2p2.on('peerclose', (peer) => disconnect$.next(peer as any));\n\n//         const message$ = new Subject<PeerWithMessage>();\n//         const response$ = new Subject<PeerWithResponse>();\n//         p2p2.on('msg', (peer, messageOrResponse) => {\n//             if (messageOrResponse.result) {\n//                 response$.next({\n//                     peer: peer as any,\n//                     response: messageOrResponse\n//                 });\n//             } else {\n//                 message$.next({\n//                     peer: peer as any,\n//                     message: messageOrResponse\n//                 });\n//             }\n\n//         });\n\n//         const handler: P2PConnectionHandler = {\n//             connect$,\n//             disconnect$,\n//             message$,\n//             response$,\n//             async send(peer: P2PPeer, message: P2PMessage) {\n//                 const [responsePeer, response] = await p2p2.send(peer as any, message);\n//                 return {\n//                     peer: responsePeer,\n//                     response\n//                 } as any;\n//             },\n//             destroy() {\n//                 p2p2.destroy();\n//                 connect$.complete();\n//                 disconnect$.complete();\n//                 message$.complete();\n//                 response$.complete();\n//                 return PROMISE_RESOLVE_VOID;\n//             }\n//         }\n//         p2p2.start();\n//         return handler;\n//     };\n//     return creator;\n// }\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","ignoreList":[]}