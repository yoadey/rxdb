{"version":3,"file":"cleanup-state.js","names":["PROMISE_RESOLVE_TRUE","REPLICATION_STATE_BY_COLLECTION","DEFAULT_CLEANUP_POLICY","initialCleanupWait","RXSTATE_CLEANUP_QUEUE","startCleanupForRxState","state","rxCollection","collection","rxDatabase","database","cleanupPolicy","Object","assign","destroyed","cleanupRxState","runCleanupAfterWrite","isDone","awaitReplicationsInSync","replicationStates","get","Promise","all","map","replicationState","isStopped","awaitInSync","then","requestIdlePromise","_cleanup","promiseWait","runEach"],"sources":["../../../../src/plugins/cleanup/cleanup-state.ts"],"sourcesContent":["import type { RxCleanupPolicy, RxCollection, RxState } from '../../types/index.d.ts';\nimport { PROMISE_RESOLVE_TRUE } from '../../plugins/utils/index.ts';\nimport { REPLICATION_STATE_BY_COLLECTION } from '../replication/index.ts';\nimport { DEFAULT_CLEANUP_POLICY } from './cleanup-helper.ts';\nimport { initialCleanupWait } from './cleanup.ts';\n\nlet RXSTATE_CLEANUP_QUEUE: Promise<any> = PROMISE_RESOLVE_TRUE;\n\nexport async function startCleanupForRxState(state: RxState<unknown, unknown>) {\n    const rxCollection = state.collection;\n    const rxDatabase = rxCollection.database;\n    const cleanupPolicy = Object.assign(\n        {},\n        DEFAULT_CLEANUP_POLICY,\n        rxDatabase.cleanupPolicy ? rxDatabase.cleanupPolicy : {}\n    );\n\n    await initialCleanupWait(rxCollection, cleanupPolicy);\n    if (rxCollection.destroyed) {\n        return;\n    }\n\n    // initially cleanup the state\n    await cleanupRxState(state, cleanupPolicy);\n\n    /**\n     * Afterwards we listen to writes\n     * and only re-run the cleanup if there was a write\n     * to the state.\n     */\n    await runCleanupAfterWrite(state, cleanupPolicy);\n}\n/**\n * Runs the cleanup for a single RxState\n */\nexport async function cleanupRxState(\n    state: RxState<unknown, unknown>,\n    cleanupPolicy: RxCleanupPolicy\n) {\n    const rxCollection = state.collection;\n    const rxDatabase = rxCollection.database;\n\n    // run cleanup() until it returns true\n    let isDone = false;\n    while (!isDone && !rxCollection.destroyed) {\n        if (cleanupPolicy.awaitReplicationsInSync) {\n            const replicationStates = REPLICATION_STATE_BY_COLLECTION.get(rxCollection);\n            if (replicationStates) {\n                await Promise.all(\n                    replicationStates.map(replicationState => {\n                        if (!replicationState.isStopped()) {\n                            return replicationState.awaitInSync();\n                        }\n                    })\n                );\n            }\n        }\n        if (rxCollection.destroyed) {\n            return;\n        }\n        RXSTATE_CLEANUP_QUEUE = RXSTATE_CLEANUP_QUEUE\n            .then(async () => {\n                if (rxCollection.destroyed) {\n                    return true;\n                }\n                await rxDatabase.requestIdlePromise();\n                return state._cleanup();\n            });\n        isDone = await RXSTATE_CLEANUP_QUEUE;\n    }\n}\n\n/**\n * TODO this is not waiting for writes!\n * it just runs on interval.\n */\nexport async function runCleanupAfterWrite(\n    state: RxState<unknown, unknown>,\n    cleanupPolicy: RxCleanupPolicy\n) {\n    const rxCollection = state.collection;\n    while (!rxCollection.destroyed) {\n        await rxCollection.promiseWait(cleanupPolicy.runEach);\n        if (rxCollection.destroyed) {\n            return;\n        }\n        await cleanupRxState(state, cleanupPolicy);\n    }\n}\n"],"mappings":"AACA,SAASA,oBAAoB,QAAQ,8BAA8B;AACnE,SAASC,+BAA+B,QAAQ,yBAAyB;AACzE,SAASC,sBAAsB,QAAQ,qBAAqB;AAC5D,SAASC,kBAAkB,QAAQ,cAAc;AAEjD,IAAIC,qBAAmC,GAAGJ,oBAAoB;AAE9D,OAAO,eAAeK,sBAAsBA,CAACC,KAAgC,EAAE;EAC3E,IAAMC,YAAY,GAAGD,KAAK,CAACE,UAAU;EACrC,IAAMC,UAAU,GAAGF,YAAY,CAACG,QAAQ;EACxC,IAAMC,aAAa,GAAGC,MAAM,CAACC,MAAM,CAC/B,CAAC,CAAC,EACFX,sBAAsB,EACtBO,UAAU,CAACE,aAAa,GAAGF,UAAU,CAACE,aAAa,GAAG,CAAC,CAC3D,CAAC;EAED,MAAMR,kBAAkB,CAACI,YAAY,EAAEI,aAAa,CAAC;EACrD,IAAIJ,YAAY,CAACO,SAAS,EAAE;IACxB;EACJ;;EAEA;EACA,MAAMC,cAAc,CAACT,KAAK,EAAEK,aAAa,CAAC;;EAE1C;AACJ;AACA;AACA;AACA;EACI,MAAMK,oBAAoB,CAACV,KAAK,EAAEK,aAAa,CAAC;AACpD;AACA;AACA;AACA;AACA,OAAO,eAAeI,cAAcA,CAChCT,KAAgC,EAChCK,aAA8B,EAChC;EACE,IAAMJ,YAAY,GAAGD,KAAK,CAACE,UAAU;EACrC,IAAMC,UAAU,GAAGF,YAAY,CAACG,QAAQ;;EAExC;EACA,IAAIO,MAAM,GAAG,KAAK;EAClB,OAAO,CAACA,MAAM,IAAI,CAACV,YAAY,CAACO,SAAS,EAAE;IACvC,IAAIH,aAAa,CAACO,uBAAuB,EAAE;MACvC,IAAMC,iBAAiB,GAAGlB,+BAA+B,CAACmB,GAAG,CAACb,YAAY,CAAC;MAC3E,IAAIY,iBAAiB,EAAE;QACnB,MAAME,OAAO,CAACC,GAAG,CACbH,iBAAiB,CAACI,GAAG,CAACC,gBAAgB,IAAI;UACtC,IAAI,CAACA,gBAAgB,CAACC,SAAS,CAAC,CAAC,EAAE;YAC/B,OAAOD,gBAAgB,CAACE,WAAW,CAAC,CAAC;UACzC;QACJ,CAAC,CACL,CAAC;MACL;IACJ;IACA,IAAInB,YAAY,CAACO,SAAS,EAAE;MACxB;IACJ;IACAV,qBAAqB,GAAGA,qBAAqB,CACxCuB,IAAI,CAAC,YAAY;MACd,IAAIpB,YAAY,CAACO,SAAS,EAAE;QACxB,OAAO,IAAI;MACf;MACA,MAAML,UAAU,CAACmB,kBAAkB,CAAC,CAAC;MACrC,OAAOtB,KAAK,CAACuB,QAAQ,CAAC,CAAC;IAC3B,CAAC,CAAC;IACNZ,MAAM,GAAG,MAAMb,qBAAqB;EACxC;AACJ;;AAEA;AACA;AACA;AACA;AACA,OAAO,eAAeY,oBAAoBA,CACtCV,KAAgC,EAChCK,aAA8B,EAChC;EACE,IAAMJ,YAAY,GAAGD,KAAK,CAACE,UAAU;EACrC,OAAO,CAACD,YAAY,CAACO,SAAS,EAAE;IAC5B,MAAMP,YAAY,CAACuB,WAAW,CAACnB,aAAa,CAACoB,OAAO,CAAC;IACrD,IAAIxB,YAAY,CAACO,SAAS,EAAE;MACxB;IACJ;IACA,MAAMC,cAAc,CAACT,KAAK,EAAEK,aAAa,CAAC;EAC9C;AACJ","ignoreList":[]}