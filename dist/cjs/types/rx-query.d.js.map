{"version":3,"file":"rx-query.d.js","names":[],"sources":["../../../src/types/rx-query.d.ts"],"sourcesContent":["import type {\n    RxQueryBase\n} from '../rx-query.d.ts';\nimport type { Paths, StringKeys } from './util.d.ts';\n\n/**\n * Typed Mango Query Selector\n * @link https://github.com/mongodb/node-mongodb-native/blob/26bce4a8debb65df5a42dc8599e886c9c83de10d/src/mongo_types.ts\n * @link https://stackoverflow.com/a/58436959/3443137\n */\n\n\nexport type PropertyType<Type, Property extends string> = string extends Property\n    ? unknown\n    : Property extends keyof Type\n    ? Type[Property]\n    : Property extends `${number}`\n    ? Type extends ReadonlyArray<infer ArrayType>\n    ? ArrayType\n    : unknown\n    : Property extends `${infer Key}.${infer Rest}`\n    ? Key extends `${number}`\n    ? Type extends ReadonlyArray<infer ArrayType>\n    ? PropertyType<ArrayType, Rest>\n    : unknown\n    : Key extends keyof Type\n    ? Type[Key] extends Map<string, infer MapType>\n    ? MapType\n    : PropertyType<Type[Key], Rest>\n    : unknown\n    : unknown;\n\n\nexport type MangoQueryRegexOptions = 'i' | 'g' | 'm' | 'gi' | 'ig' | 'igm' | string;\n\n/*\n * The MongoDB query library is huge and we do not need all the operators.\n * If you add an operator here, make sure that you properly add a test in\n * the file /test/unit/rx-storage-query-correctness.test.ts\n *\n * @link https://github.com/kofrasa/mingo#es6\n */\nexport interface MangoQueryOperators<PathValueType> {\n    $eq?: PathValueType;\n    $gt?: PathValueType;\n    $gte?: PathValueType;\n    $lt?: PathValueType;\n    $lte?: PathValueType;\n    $ne?: PathValueType;\n    $in?: PathValueType[];\n    $nin?: PathValueType[];\n    $regex?: string;\n    $options?: MangoQueryRegexOptions;\n    $exists?: boolean;\n    $type?: 'null' | 'boolean' | 'number' | 'string' | 'array' | 'object';\n    $mod?: number;\n    $not?: PathValueType;\n    $size?: number;\n    $elemMatch?: MangoQuerySelector<PathValueType>;\n}\n\nexport type MangoQuerySelector<DocType> = Partial<{\n    [Property in Paths<DocType>]: MangoQueryOperators<any> | PropertyType<DocType, Property>;\n}> & {\n    $and?: MangoQuerySelector<DocType>[];\n    $or?: MangoQuerySelector<DocType>[];\n    $nor?: MangoQuerySelector<DocType>[];\n};\n\n/**\n * Discussion was at:\n * @link https://github.com/pubkey/rxdb/issues/1972\n */\nexport type MangoQuerySortDirection = 'asc' | 'desc';\nexport type MangoQuerySortPart<RxDocType = any> = {\n    [k in StringKeys<RxDocType> | string]: MangoQuerySortDirection;\n};\n\nexport type MangoQuerySelectorAndIndex<RxDocType = any> = {\n    /**\n     * Selector is optional,\n     * if not given, the query matches all documents\n     * that are not _deleted=true.\n     */\n    selector?: MangoQuerySelector<RxDocType>;\n    /**\n     * By default, the RxStorage implementation\n     * decides which index to use when running the query.\n     *\n     * For better performance, a different index might be defined\n     * by setting it in the query.\n     * How this improves performance and if the defined index is used,\n     * depends on the RxStorage implementation.\n     */\n    index?: string | string[];\n};\n\nexport type MangoQueryNoLimit<RxDocType> = MangoQuerySelectorAndIndex<RxDocType> & {\n    /**\n     * Sorting of the results.\n     * If no sort is set, RxDB will sort by the primary key.\n     * Also if sort is set, RxDB will add primaryKey sorting\n     * if the primaryKey was not in the sort parameters before.\n     * This ensures that there is a deterministic sorting of the\n     * results, not mather at which order the documents have been\n     * inserted into the storage.\n     */\n    sort?: MangoQuerySortPart<RxDocType>[];\n};\n\nexport type MangoQuery<RxDocType = any> = MangoQueryNoLimit<RxDocType> & {\n    skip?: number;\n    limit?: number;\n};\n\nexport type RxQueryOP = 'find' | 'findOne' | 'count' | 'findByIds';\n\nexport declare class RxQuery<\n    RxDocumentType = any,\n    RxQueryResult = any,\n    OrmMethods = {},\n    Reactivity = unknown\n> extends RxQueryBase<RxDocumentType, RxQueryResult, OrmMethods, Reactivity> {\n    equals(queryObj: any): RxQuery<RxDocumentType, RxQueryResult>;\n    eq(queryObj: any): RxQuery<RxDocumentType, RxQueryResult>;\n    or(queryObj: keyof RxDocumentType | string | any[]): RxQuery<RxDocumentType, RxQueryResult>;\n    nor(queryObj: keyof RxDocumentType | string | any[]): RxQuery<RxDocumentType, RxQueryResult>;\n    and(queryObj: keyof RxDocumentType | string | any[]): RxQuery<RxDocumentType, RxQueryResult>;\n    gt(queryObj: any): RxQuery<RxDocumentType, RxQueryResult>;\n    gte(queryObj: any): RxQuery<RxDocumentType, RxQueryResult>;\n    lt(queryObj: any): RxQuery<RxDocumentType, RxQueryResult>;\n    lte(queryObj: any): RxQuery<RxDocumentType, RxQueryResult>;\n    ne(queryObj: any): RxQuery<RxDocumentType, RxQueryResult>;\n    in(queryObj: any[]): RxQuery<RxDocumentType, RxQueryResult>;\n    nin(queryObj: any[]): RxQuery<RxDocumentType, RxQueryResult>;\n    all(queryObj: any): RxQuery<RxDocumentType, RxQueryResult>;\n    regex(queryObj: string | {\n        $regex: string;\n        $options: MangoQueryRegexOptions;\n    }): RxQuery<RxDocumentType, RxQueryResult>;\n    exists(queryObj: any): RxQuery<RxDocumentType, RxQueryResult>;\n    elemMatch(queryObj: any): RxQuery<RxDocumentType, RxQueryResult>;\n    mod(p1: any, p2: any, p3: any): RxQuery<RxDocumentType, RxQueryResult>;\n}\n"],"mappings":"","ignoreList":[]}