{"version":3,"file":"index.js","names":["_rxjs","require","_rxSchemaHelper","_index","_checkpoint","Object","keys","forEach","key","prototype","hasOwnProperty","call","_exportNames","exports","defineProperty","enumerable","get","_downstream","_helper","_upstream","_index2","_rxStorageHelper","_metaInstance","_conflicts","replicateRxStorageInstance","input","flatClone","forkInstance","getUnderlyingPersistentStorage","metaInstance","checkpointKeyPromise","getCheckpointKey","state","primaryPath","getPrimaryFieldOfPrimaryKey","schema","primaryKey","hasAttachments","attachments","checkpointKey","downstreamBulkWriteFlag","then","events","canceled","BehaviorSubject","active","down","up","processed","Subject","resolvedConflicts","error","stats","addNewTask","downstreamProcessChanges","downstreamResyncOnce","masterChangeStreamEmit","persistFromMaster","forkChangeStreamEmit","persistToMaster","persistToMasterConflictWrites","persistToMasterHadConflicts","processTasks","upstreamInitialSync","firstSyncDone","streamQueue","PROMISE_RESOLVE_VOID","checkpointQueue","lastCheckpointDoc","startReplicationDownstream","startReplicationUpstream","awaitRxStorageReplicationFirstInSync","firstValueFrom","combineLatest","pipe","filter","v","awaitRxStorageReplicationInSync","replicationState","Promise","all","awaitRxStorageReplicationIdle","rxStorageInstanceToReplicationHandler","instance","conflictHandler","databaseInstanceToken","keepMeta","replicationHandler","masterChangeStream$","changeStream","mergeMap","eventBulk","ret","checkpoint","documents","map","event","docData","writeDocToDocState","documentData","fillWriteDataForAttachmentsChange","clone","undefined","masterChangesSince","batchSize","getChangedDocumentsSince","result","length","plainDocumentData","masterWrite","rows","rowById","row","docId","newDocumentState","ids","masterDocsStateList","findDocumentsById","masterDocsState","Map","doc","set","conflicts","writeRows","entries","id","masterState","push","document","docStateToWriteDoc","assumedMasterState","realMasterState","ensureNotFalsy","isEqual","previous","bulkWrite","err","status","Error","documentInDb","cancelRxStorageReplication","next","complete"],"sources":["../../../src/replication-protocol/index.ts"],"sourcesContent":["/**\n * These files contain the replication protocol.\n * It can be used to replicated RxStorageInstances or RxCollections\n * or even to do a client(s)-server replication.\n */\n\n\nimport {\n    BehaviorSubject,\n    combineLatest,\n    filter,\n    firstValueFrom,\n    mergeMap,\n    Subject\n} from 'rxjs';\nimport {\n    getPrimaryFieldOfPrimaryKey\n} from '../rx-schema-helper.ts';\nimport type {\n    BulkWriteRow,\n    ById,\n    DocumentsWithCheckpoint,\n    RxConflictHandler,\n    RxDocumentData,\n    RxReplicationHandler,\n    RxReplicationWriteToMasterRow,\n    RxStorageInstance,\n    RxStorageInstanceReplicationInput,\n    RxStorageInstanceReplicationState,\n    WithDeleted\n} from '../types/index.d.ts';\nimport {\n    clone,\n    ensureNotFalsy,\n    flatClone,\n    PROMISE_RESOLVE_VOID\n} from '../plugins/utils/index.ts';\nimport {\n    getCheckpointKey\n} from './checkpoint.ts';\nimport { startReplicationDownstream } from './downstream.ts';\nimport { docStateToWriteDoc, getUnderlyingPersistentStorage, writeDocToDocState } from './helper.ts';\nimport { startReplicationUpstream } from './upstream.ts';\nimport { fillWriteDataForAttachmentsChange } from '../plugins/attachments/index.ts';\nimport { getChangedDocumentsSince } from '../rx-storage-helper.ts';\n\n\nexport * from './checkpoint.ts';\nexport * from './downstream.ts';\nexport * from './upstream.ts';\nexport * from './meta-instance.ts';\nexport * from './conflicts.ts';\nexport * from './helper.ts';\n\n\nexport function replicateRxStorageInstance<RxDocType>(\n    input: RxStorageInstanceReplicationInput<RxDocType>\n): RxStorageInstanceReplicationState<RxDocType> {\n    input = flatClone(input);\n    input.forkInstance = getUnderlyingPersistentStorage(input.forkInstance);\n    input.metaInstance = getUnderlyingPersistentStorage(input.metaInstance);\n    const checkpointKeyPromise = getCheckpointKey(input);\n    const state: RxStorageInstanceReplicationState<RxDocType> = {\n        primaryPath: getPrimaryFieldOfPrimaryKey(input.forkInstance.schema.primaryKey),\n        hasAttachments: !!input.forkInstance.schema.attachments,\n        input,\n        checkpointKey: checkpointKeyPromise,\n        downstreamBulkWriteFlag: checkpointKeyPromise.then(checkpointKey => 'replication-downstream-' + checkpointKey),\n        events: {\n            canceled: new BehaviorSubject<boolean>(false),\n            active: {\n                down: new BehaviorSubject<boolean>(true),\n                up: new BehaviorSubject<boolean>(true)\n            },\n            processed: {\n                down: new Subject(),\n                up: new Subject()\n            },\n            resolvedConflicts: new Subject(),\n            error: new Subject()\n        },\n        stats: {\n            down: {\n                addNewTask: 0,\n                downstreamProcessChanges: 0,\n                downstreamResyncOnce: 0,\n                masterChangeStreamEmit: 0,\n                persistFromMaster: 0\n            },\n            up: {\n                forkChangeStreamEmit: 0,\n                persistToMaster: 0,\n                persistToMasterConflictWrites: 0,\n                persistToMasterHadConflicts: 0,\n                processTasks: 0,\n                upstreamInitialSync: 0\n            }\n        },\n        firstSyncDone: {\n            down: new BehaviorSubject<boolean>(false),\n            up: new BehaviorSubject<boolean>(false)\n        },\n        streamQueue: {\n            down: PROMISE_RESOLVE_VOID,\n            up: PROMISE_RESOLVE_VOID\n        },\n        checkpointQueue: PROMISE_RESOLVE_VOID,\n        lastCheckpointDoc: {}\n    };\n\n    startReplicationDownstream(state);\n    startReplicationUpstream(state);\n    return state;\n}\n\nexport function awaitRxStorageReplicationFirstInSync(\n    state: RxStorageInstanceReplicationState<any>\n): Promise<void> {\n    return firstValueFrom(\n        combineLatest([\n            state.firstSyncDone.down.pipe(\n                filter(v => !!v)\n            ),\n            state.firstSyncDone.up.pipe(\n                filter(v => !!v)\n            )\n        ])\n    ).then(() => { });\n}\n\nexport function awaitRxStorageReplicationInSync(\n    replicationState: RxStorageInstanceReplicationState<any>\n) {\n    return Promise.all([\n        replicationState.streamQueue.up,\n        replicationState.streamQueue.down,\n        replicationState.checkpointQueue\n    ]);\n}\n\n\nexport async function awaitRxStorageReplicationIdle(\n    state: RxStorageInstanceReplicationState<any>\n) {\n    await awaitRxStorageReplicationFirstInSync(state);\n    while (true) {\n        const { down, up } = state.streamQueue;\n        await Promise.all([\n            up,\n            down\n        ]);\n        /**\n         * If the Promises have not been reassigned\n         * after awaiting them, we know that the replication\n         * is in idle state at this point in time.\n         */\n        if (\n            down === state.streamQueue.down &&\n            up === state.streamQueue.up\n        ) {\n            return;\n        }\n    }\n}\n\n\nexport function rxStorageInstanceToReplicationHandler<RxDocType, MasterCheckpointType>(\n    instance: RxStorageInstance<RxDocType, any, any, MasterCheckpointType>,\n    conflictHandler: RxConflictHandler<RxDocType>,\n    databaseInstanceToken: string,\n    /**\n     * If set to true,\n     * the _meta.lwt from the pushed documents is kept.\n     * (Used in the migration to ensure checkpoints are still valid)\n     */\n    keepMeta: boolean = false\n): RxReplicationHandler<RxDocType, MasterCheckpointType> {\n    instance = getUnderlyingPersistentStorage(instance);\n\n    const hasAttachments = !!instance.schema.attachments;\n    const primaryPath = getPrimaryFieldOfPrimaryKey(instance.schema.primaryKey);\n    const replicationHandler: RxReplicationHandler<RxDocType, MasterCheckpointType> = {\n        masterChangeStream$: instance.changeStream().pipe(\n            mergeMap(async (eventBulk) => {\n                const ret: DocumentsWithCheckpoint<RxDocType, MasterCheckpointType> = {\n                    checkpoint: eventBulk.checkpoint,\n                    documents: await Promise.all(\n                        eventBulk.events.map(async (event) => {\n                            let docData = writeDocToDocState(event.documentData, hasAttachments, keepMeta);\n                            if (hasAttachments) {\n                                docData = await fillWriteDataForAttachmentsChange(\n                                    primaryPath,\n                                    instance,\n                                    clone(docData),\n                                    /**\n                                     * Notice that the master never knows\n                                     * the client state of the document.\n                                     * Therefore we always send all attachments data.\n                                     */\n                                    undefined\n                                );\n                            }\n\n                            return docData;\n                        })\n                    )\n                };\n                return ret;\n            })\n        ),\n        masterChangesSince(\n            checkpoint,\n            batchSize\n        ) {\n            return getChangedDocumentsSince(\n                instance,\n                batchSize,\n                checkpoint\n            ).then(async (result) => {\n                return {\n                    checkpoint: result.documents.length > 0 ? result.checkpoint : checkpoint,\n                    documents: await Promise.all(\n                        result.documents.map(async (plainDocumentData) => {\n                            let docData = writeDocToDocState(plainDocumentData, hasAttachments, keepMeta);\n                            if (hasAttachments) {\n                                docData = await fillWriteDataForAttachmentsChange(\n                                    primaryPath,\n                                    instance,\n                                    clone(docData),\n                                    /**\n                                     * Notice the the master never knows\n                                     * the client state of the document.\n                                     * Therefore we always send all attachments data.\n                                     */\n                                    undefined\n                                );\n                            }\n                            return docData;\n                        })\n                    )\n                };\n            });\n        },\n        async masterWrite(\n            rows\n        ) {\n            const rowById: ById<RxReplicationWriteToMasterRow<RxDocType>> = {};\n            rows.forEach(row => {\n                const docId: string = (row.newDocumentState as any)[primaryPath];\n                rowById[docId] = row;\n            });\n            const ids = Object.keys(rowById);\n\n            const masterDocsStateList = await instance.findDocumentsById(\n                ids,\n                true\n            );\n            const masterDocsState = new Map<string, RxDocumentData<RxDocType>>();\n            masterDocsStateList.forEach(doc => masterDocsState.set((doc as any)[primaryPath], doc));\n            const conflicts: WithDeleted<RxDocType>[] = [];\n            const writeRows: BulkWriteRow<RxDocType>[] = [];\n            await Promise.all(\n                Object.entries(rowById)\n                    .map(async ([id, row]) => {\n                        const masterState = masterDocsState.get(id);\n                        if (!masterState) {\n                            writeRows.push({\n                                document: docStateToWriteDoc(databaseInstanceToken, hasAttachments, keepMeta, row.newDocumentState)\n                            });\n                        } else if (\n                            masterState &&\n                            !row.assumedMasterState\n                        ) {\n                            conflicts.push(writeDocToDocState(masterState, hasAttachments, keepMeta));\n                        } else if (\n                            (await conflictHandler({\n                                realMasterState: writeDocToDocState(masterState, hasAttachments, keepMeta),\n                                newDocumentState: ensureNotFalsy(row.assumedMasterState)\n                            }, 'rxStorageInstanceToReplicationHandler-masterWrite')).isEqual === true\n                        ) {\n                            writeRows.push({\n                                previous: masterState,\n                                document: docStateToWriteDoc(databaseInstanceToken, hasAttachments, keepMeta, row.newDocumentState, masterState)\n                            });\n                        } else {\n                            conflicts.push(writeDocToDocState(masterState, hasAttachments, keepMeta));\n                        }\n                    })\n            );\n\n            if (writeRows.length > 0) {\n                const result = await instance.bulkWrite(\n                    writeRows,\n                    'replication-master-write'\n                );\n\n                result.error.forEach(err => {\n                    if (err.status !== 409) {\n                        throw new Error('non conflict error');\n                    } else {\n                        conflicts.push(\n                            writeDocToDocState(ensureNotFalsy(err.documentInDb), hasAttachments, keepMeta)\n                        );\n                    }\n                });\n            }\n            return conflicts;\n        }\n    };\n\n    return replicationHandler;\n}\n\n\nexport async function cancelRxStorageReplication(\n    replicationState: RxStorageInstanceReplicationState<any>\n) {\n    replicationState.events.canceled.next(true);\n    replicationState.events.active.up.complete();\n    replicationState.events.active.down.complete();\n    replicationState.events.processed.up.complete();\n    replicationState.events.processed.down.complete();\n    replicationState.events.resolvedConflicts.complete();\n    replicationState.events.canceled.complete();\n    await replicationState.checkpointQueue;\n}\n"],"mappings":"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","ignoreList":[]}