{"version":3,"file":"index.js","names":["path","BehaviorSubject","firstValueFrom","Subject","filter","map","getFromMapOrCreate","PROMISE_RESOLVE_FALSE","PROMISE_RESOLVE_TRUE","PROMISE_RESOLVE_VOID","clearFolder","deleteFolder","documentFolder","ensureFolderExists","getMeta","prepareFolders","setMeta","writeJsonToFile","writeToFile","getChangedDocumentsSince","backupSingleDocument","rxDocument","options","data","toJSON","writtenFiles","docFolder","primary","fileLocation","join","push","attachments","attachmentsFolder","allAttachments","Promise","all","attachment","content","getData","attachmentFileLocation","id","BACKUP_STATES_BY_DB","WeakMap","addToBackupStates","db","state","ar","RxBackupState","database","isStopped","subs","persistRunning","initialReplicationDone$","internalWriteEvents$","writeEvents$","asObservable","batchSize","_proto","prototype","persistOnce","then","_persistOnce","_this","meta","Object","entries","collections","collectionName","collection","primaryKey","schema","primaryPath","processedDocuments","Set","requestIdlePromise","collectionStates","lastCheckpoint","checkpoint","hasMore","_loop","changesResult","storageInstance","documents","length","docIds","doc","has","add","elem","pos","arr","indexOf","docs","findByIds","exec","size","Array","from","values","next","name","documentId","files","deleted","docId","getValue","watchForChanges","forEach","changes$","changeStream","sub","subscribe","awaitInitialBackup","pipe","v","cancel","unsubscribe","backup","backupState","live","RxDBBackupPlugin","rxdb","prototypes","RxDatabase","proto","hooks","preDestroyRxDatabase","after","states","get"],"sources":["../../../../src/plugins/backup/index.ts"],"sourcesContent":["import * as path from 'node:path';\nimport {\n    BehaviorSubject,\n    firstValueFrom,\n    Observable,\n    Subject,\n    Subscription\n} from 'rxjs';\nimport {\n    filter,\n    map\n} from 'rxjs';\nimport type {\n    BackupOptions,\n    RxBackupWriteEvent,\n    RxCollection,\n    RxDatabase,\n    RxDocument,\n    RxPlugin\n} from '../../types/index.d.ts';\nimport {\n    getFromMapOrCreate,\n    PROMISE_RESOLVE_FALSE,\n    PROMISE_RESOLVE_TRUE,\n    PROMISE_RESOLVE_VOID\n} from '../../plugins/utils/index.ts';\nimport {\n    clearFolder,\n    deleteFolder,\n    documentFolder,\n    ensureFolderExists,\n    getMeta,\n    prepareFolders,\n    setMeta,\n    writeJsonToFile,\n    writeToFile\n} from './file-util.ts';\nimport { getChangedDocumentsSince } from '../../rx-storage-helper.ts';\n\n\n/**\n * Backups a single documents,\n * returns the paths to all written files\n */\nexport async function backupSingleDocument(\n    rxDocument: RxDocument<any, any>,\n    options: BackupOptions\n): Promise<string[]> {\n    const data = rxDocument.toJSON(true);\n    const writtenFiles: string[] = [];\n\n    const docFolder = documentFolder(options, rxDocument.primary);\n    await clearFolder(docFolder);\n\n    const fileLocation = path.join(\n        docFolder,\n        'document.json'\n    );\n    await writeJsonToFile(fileLocation, data);\n    writtenFiles.push(fileLocation);\n\n    if (options.attachments) {\n        const attachmentsFolder = path.join(\n            docFolder,\n            'attachments'\n        );\n        ensureFolderExists(attachmentsFolder);\n        const attachments = (rxDocument as RxDocument).allAttachments();\n        await Promise.all(\n            attachments\n                .map(async (attachment) => {\n                    const content = await attachment.getData();\n                    const attachmentFileLocation = path.join(\n                        attachmentsFolder,\n                        attachment.id\n                    );\n                    await writeToFile(attachmentFileLocation, content);\n                    writtenFiles.push(attachmentFileLocation);\n                })\n        );\n    }\n\n    return writtenFiles;\n}\n\nconst BACKUP_STATES_BY_DB: WeakMap<RxDatabase, RxBackupState[]> = new WeakMap();\nfunction addToBackupStates(db: RxDatabase, state: RxBackupState) {\n    const ar = getFromMapOrCreate(\n        BACKUP_STATES_BY_DB,\n        db,\n        () => []\n    );\n    ar.push(state);\n}\n\nexport class RxBackupState {\n    public isStopped: boolean = false;\n    private subs: Subscription[] = [];\n    private persistRunning: Promise<void> = PROMISE_RESOLVE_VOID;\n    private initialReplicationDone$: BehaviorSubject<boolean> = new BehaviorSubject(false as any);\n\n    private readonly internalWriteEvents$: Subject<RxBackupWriteEvent> = new Subject();\n    public readonly writeEvents$: Observable<RxBackupWriteEvent> = this.internalWriteEvents$.asObservable();\n\n    constructor(\n        public readonly database: RxDatabase,\n        public readonly options: BackupOptions\n    ) {\n        if (!this.options.batchSize) {\n            this.options.batchSize = 10;\n        }\n        addToBackupStates(database, this);\n        prepareFolders(database, options);\n    }\n\n    /**\n     * Persists all data from all collections,\n     * beginning from the oldest sequence checkpoint\n     * to the newest one.\n     * Do not call this while it is already running.\n     * Returns true if there are more documents to process\n     */\n    public persistOnce() {\n        return this.persistRunning = this.persistRunning.then(() => this._persistOnce());\n    }\n\n    public async _persistOnce() {\n        const meta = await getMeta(this.options);\n\n        await Promise.all(\n            Object\n                .entries(this.database.collections)\n                .map(async ([collectionName, collection]) => {\n                    const primaryKey = collection.schema.primaryPath;\n                    const processedDocuments: Set<string> = new Set();\n\n                    await this.database.requestIdlePromise();\n\n                    if (!meta.collectionStates[collectionName]) {\n                        meta.collectionStates[collectionName] = {};\n                    }\n                    let lastCheckpoint = meta.collectionStates[collectionName].checkpoint;\n\n                    let hasMore = true;\n                    while (hasMore && !this.isStopped) {\n                        await this.database.requestIdlePromise();\n                        const changesResult = await getChangedDocumentsSince(\n                            collection.storageInstance,\n                            this.options.batchSize ? this.options.batchSize : 0,\n                            lastCheckpoint\n                        );\n                        lastCheckpoint = changesResult.documents.length > 0 ? changesResult.checkpoint : lastCheckpoint;\n                        meta.collectionStates[collectionName].checkpoint = lastCheckpoint;\n\n                        const docIds: string[] = changesResult.documents\n                            .map(doc => doc[primaryKey])\n                            .filter(id => {\n                                if (\n                                    processedDocuments.has(id)\n                                ) {\n                                    return false;\n                                } else {\n                                    processedDocuments.add(id);\n                                    return true;\n                                }\n                            })\n                            .filter((elem, pos, arr) => arr.indexOf(elem) === pos); // unique\n                        await this.database.requestIdlePromise();\n\n                        const docs: Map<string, RxDocument> = await collection.findByIds(docIds).exec();\n                        if (docs.size === 0) {\n                            hasMore = false;\n                            continue;\n                        }\n                        await Promise.all(\n                            Array\n                                .from(docs.values())\n                                .map(async (doc) => {\n                                    const writtenFiles = await backupSingleDocument(doc, this.options);\n                                    this.internalWriteEvents$.next({\n                                        collectionName: collection.name,\n                                        documentId: doc.primary,\n                                        files: writtenFiles,\n                                        deleted: false\n                                    });\n                                })\n                        );\n                        // handle deleted documents\n                        await Promise.all(\n                            docIds\n                                .filter(docId => !docs.has(docId))\n                                .map(async (docId) => {\n                                    await deleteFolder(documentFolder(this.options, docId));\n                                    this.internalWriteEvents$.next({\n                                        collectionName: collection.name,\n                                        documentId: docId,\n                                        files: [],\n                                        deleted: true\n                                    });\n                                })\n                        );\n                    }\n                    meta.collectionStates[collectionName].checkpoint = lastCheckpoint;\n                    await setMeta(this.options, meta);\n                })\n        );\n\n        if (!this.initialReplicationDone$.getValue()) {\n            this.initialReplicationDone$.next(true);\n        }\n    }\n\n    public watchForChanges() {\n        const collections: RxCollection[] = Object.values(this.database.collections);\n        collections.forEach(collection => {\n            const changes$ = collection.storageInstance.changeStream();\n            const sub = changes$.subscribe(() => {\n                this.persistOnce();\n            });\n            this.subs.push(sub);\n        });\n    }\n\n    /**\n     * Returns a promise that resolves when the initial backup is done\n     * and the filesystem is in sync with the database state\n     */\n    public awaitInitialBackup(): Promise<boolean> {\n        return firstValueFrom(\n            this.initialReplicationDone$.pipe(\n                filter(v => !!v),\n                map(() => true)\n            )\n        );\n    }\n\n    cancel(): Promise<boolean> {\n        if (this.isStopped) {\n            return PROMISE_RESOLVE_FALSE;\n        }\n        this.isStopped = true;\n        this.subs.forEach(sub => sub.unsubscribe());\n        return PROMISE_RESOLVE_TRUE;\n    }\n}\n\n\nexport function backup(\n    this: RxDatabase,\n    options: BackupOptions\n): RxBackupState {\n    const backupState = new RxBackupState(this, options);\n    backupState.persistOnce();\n\n    if (options.live) {\n        backupState.watchForChanges();\n    }\n\n    return backupState;\n}\n\nexport * from './file-util.ts';\nexport const RxDBBackupPlugin: RxPlugin = {\n    name: 'backup',\n    rxdb: true,\n    prototypes: {\n        RxDatabase(proto: any) {\n            proto.backup = backup;\n        }\n    },\n    hooks: {\n        preDestroyRxDatabase: {\n            after: function preDestroyRxDatabase(db: RxDatabase) {\n                const states = BACKUP_STATES_BY_DB.get(db);\n                if (states) {\n                    states.forEach(state => state.cancel());\n                }\n            }\n        }\n    }\n};\n"],"mappings":"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","ignoreList":[]}