{"version":3,"file":"upstream.js","names":["_rxjs","require","_rxStorageHelper","_index","_checkpoint","_conflicts","_helper","_metaInstance","_index2","startReplicationUpstream","state","input","initialCheckpoint","upstream","checkpointDoc","getLastCheckpointDoc","setCheckpoint","replicationHandler","streamQueue","up","then","upstreamInitialSync","processTasks","timer","initialSyncStartTime","taskPlanned","openTasks","persistenceQueue","PROMISE_RESOLVE_FALSE","nonPersistedFromMaster","docs","sub","forkInstance","changeStream","subscribe","eventBulk","context","downstreamBulkWriteFlag","stats","forkChangeStreamEmit","push","task","time","events","active","getValue","next","scheduleProcessTasks","firstValueFrom","canceled","pipe","filter","unsubscribe","waitBeforePersist","checkpointQueue","lastCheckpoint","promises","Set","_loop","size","Promise","race","Array","from","upResult","getChangedDocumentsSince","pushBatchSize","documents","length","stackCheckpoints","checkpoint","promise","persistToMaster","ensureNotFalsy","add","catch","delete","resolvedPromises","all","hadConflicts","find","r","firstSyncDone","taskWithTime","shift","appendToArray","map","documentData","forEach","docData","docId","primaryPath","upDocsById","useCheckpoint","docIds","Object","keys","assumedMasterState","getAssumedMasterState","writeRowsToMaster","writeRowsToMasterIds","writeRowsToMeta","forkStateById","fullDocData","writeDocToDocState","hasAttachments","keepMeta","assumedMasterDoc","metaDocument","isResolvedConflict","_rev","conflictHandler","realMasterState","newDocumentState","isEqual","parseRevision","height","_meta","identifier","undefined","getMetaWriteRow","writeRowsArray","values","conflictIds","conflictsById","writeBatches","batchArray","writeBatch","row","fillWriteDataForAttachmentsChange","clone","masterWriteResult","masterWrite","conflictDoc","id","useWriteRowsToMeta","has","processed","metaInstance","bulkWrite","stripAttachmentsDataFromMetaWriteRows","hadConflictWrites","persistToMasterHadConflicts","conflictWriteFork","conflictWriteMeta","entries","writeToMasterRow","resolveConflictError","resolved","resolvedConflicts","output","previous","document","resolvedDoc","persistToMasterConflictWrites","forkWriteResult","useMetaWrites","success","unhandledError","error"],"sources":["../../../src/replication-protocol/upstream.ts"],"sourcesContent":["import { firstValueFrom, filter } from 'rxjs';\r\nimport {\r\n    getChangedDocumentsSince,\r\n    stackCheckpoints\r\n} from '../rx-storage-helper.ts';\r\nimport type {\r\n    BulkWriteRow,\r\n    BulkWriteRowById,\r\n    ById,\r\n    EventBulk,\r\n    RxDocumentData,\r\n    RxReplicationWriteToMasterRow,\r\n    RxStorageChangeEvent,\r\n    RxStorageInstanceReplicationState,\r\n    RxStorageReplicationMeta,\r\n    WithDeleted\r\n} from '../types/index.d.ts';\r\nimport {\r\n    appendToArray,\r\n    batchArray,\r\n    clone,\r\n    ensureNotFalsy,\r\n    parseRevision,\r\n    PROMISE_RESOLVE_FALSE\r\n} from '../plugins/utils/index.ts';\r\nimport {\r\n    getLastCheckpointDoc,\r\n    setCheckpoint\r\n} from './checkpoint.ts';\r\nimport {\r\n    resolveConflictError\r\n} from './conflicts.ts';\r\nimport {\r\n    stripAttachmentsDataFromMetaWriteRows,\r\n    writeDocToDocState\r\n} from './helper.ts';\r\nimport {\r\n    getAssumedMasterState,\r\n    getMetaWriteRow\r\n} from './meta-instance.ts';\r\nimport { fillWriteDataForAttachmentsChange } from '../plugins/attachments/index.ts';\r\n\r\n/**\r\n * Writes all document changes from the fork to the master.\r\n * The upstream runs on two modes:\r\n * - For initial replication, a checkpoint-iteration is used\r\n * - For ongoing local writes, we just subscribe to the changeStream of the fork.\r\n *   In contrast to the master, the fork can be assumed to never loose connection,\r\n *   so we do not have to prepare for missed out events.\r\n */\r\nexport async function startReplicationUpstream<RxDocType, CheckpointType>(\r\n    state: RxStorageInstanceReplicationState<RxDocType>\r\n) {\r\n    if (\r\n        state.input.initialCheckpoint &&\r\n        state.input.initialCheckpoint.upstream\r\n    ) {\r\n        const checkpointDoc = await getLastCheckpointDoc(state, 'up');\r\n        if (!checkpointDoc) {\r\n            await setCheckpoint(\r\n                state,\r\n                'up',\r\n                state.input.initialCheckpoint.upstream\r\n            );\r\n        }\r\n    }\r\n\r\n    const replicationHandler = state.input.replicationHandler;\r\n    state.streamQueue.up = state.streamQueue.up.then(() => {\r\n        return upstreamInitialSync().then(() => {\r\n            processTasks();\r\n        });\r\n    });\r\n\r\n    // used to detect which tasks etc can in it at which order.\r\n    let timer = 0;\r\n    let initialSyncStartTime = -1;\r\n    let taskPlanned: boolean = false;\r\n\r\n    type Task = EventBulk<RxStorageChangeEvent<RxDocType>, any>;\r\n    type TaskWithTime = {\r\n        task: Task;\r\n        time: number;\r\n    };\r\n    const openTasks: TaskWithTime[] = [];\r\n    let persistenceQueue: Promise<boolean> = PROMISE_RESOLVE_FALSE;\r\n    const nonPersistedFromMaster: {\r\n        checkpoint?: CheckpointType;\r\n        docs: ById<RxDocumentData<RxDocType>>;\r\n    } = {\r\n        docs: {}\r\n    };\r\n\r\n    const sub = state.input.forkInstance.changeStream()\r\n        .subscribe(async (eventBulk) => {\r\n            // ignore writes that came from the downstream\r\n            if (eventBulk.context === await state.downstreamBulkWriteFlag) {\r\n                return;\r\n            }\r\n\r\n            state.stats.up.forkChangeStreamEmit = state.stats.up.forkChangeStreamEmit + 1;\r\n            openTasks.push({\r\n                task: eventBulk,\r\n                time: timer++\r\n            });\r\n            if (!state.events.active.up.getValue()) {\r\n                state.events.active.up.next(true);\r\n            }\r\n            return scheduleProcessTasks();\r\n        });\r\n    firstValueFrom(\r\n        state.events.canceled.pipe(\r\n            filter(canceled => !!canceled)\r\n        )\r\n    ).then(() => sub.unsubscribe());\r\n\r\n    function scheduleProcessTasks() {\r\n        if (!taskPlanned) {\r\n            // No need to start another task if there is one already scheduled\r\n            taskPlanned = true;\r\n            if (state.input.waitBeforePersist) {\r\n                return state.input.waitBeforePersist()\r\n                    .then(() => processTasks());\r\n            } else {\r\n                return processTasks();\r\n            }\r\n        }\r\n    }\r\n\r\n    async function upstreamInitialSync() {\r\n        state.stats.up.upstreamInitialSync = state.stats.up.upstreamInitialSync + 1;\r\n        if (state.events.canceled.getValue()) {\r\n            return;\r\n        }\r\n\r\n        state.checkpointQueue = state.checkpointQueue.then(() => getLastCheckpointDoc(state, 'up'));\r\n        let lastCheckpoint: CheckpointType = await state.checkpointQueue;\r\n\r\n        const promises: Set<Promise<any>> = new Set();\r\n\r\n        while (!state.events.canceled.getValue()) {\r\n            initialSyncStartTime = timer++;\r\n\r\n            /**\r\n             * Throttle the calls to\r\n             * forkInstance.getChangedDocumentsSince() so that\r\n             * if the pushing to the remote is slower compared to the\r\n             * pulling out of forkInstance, we do not block the UI too much\r\n             * and have a big memory spike with all forkInstance documents.\r\n             */\r\n            if (promises.size > 3) {\r\n                await Promise.race(Array.from(promises));\r\n            }\r\n\r\n            const upResult = await getChangedDocumentsSince(\r\n                state.input.forkInstance,\r\n                state.input.pushBatchSize,\r\n                lastCheckpoint\r\n            );\r\n            if (upResult.documents.length === 0) {\r\n                break;\r\n            }\r\n\r\n            lastCheckpoint = stackCheckpoints([lastCheckpoint, upResult.checkpoint]);\r\n\r\n            const promise = persistToMaster(\r\n                upResult.documents,\r\n                ensureNotFalsy(lastCheckpoint)\r\n            );\r\n            promises.add(promise);\r\n            promise.catch().then(() => promises.delete(promise));\r\n        }\r\n\r\n        /**\r\n         * If we had conflicts during the initial sync,\r\n         * it means that we likely have new writes to the fork\r\n         * and so we have to run the initial sync again to upstream these new writes.\r\n         */\r\n        const resolvedPromises = await Promise.all(promises);\r\n        const hadConflicts = resolvedPromises.find(r => !!r);\r\n        if (hadConflicts) {\r\n            await upstreamInitialSync();\r\n        } else if (\r\n            !state.firstSyncDone.up.getValue() &&\r\n            !state.events.canceled.getValue()\r\n        ) {\r\n            state.firstSyncDone.up.next(true);\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * Takes all open tasks an processes them at once.\r\n     */\r\n    function processTasks() {\r\n        taskPlanned = false;\r\n        if (\r\n            state.events.canceled.getValue() ||\r\n            openTasks.length === 0\r\n        ) {\r\n            state.events.active.up.next(false);\r\n            return;\r\n        }\r\n        state.stats.up.processTasks = state.stats.up.processTasks + 1;\r\n        state.events.active.up.next(true);\r\n        state.streamQueue.up = state.streamQueue.up.then(() => {\r\n            /**\r\n             * Merge/filter all open tasks\r\n             */\r\n            const docs: RxDocumentData<RxDocType>[] = [];\r\n            let checkpoint: CheckpointType = {} as any;\r\n            while (openTasks.length > 0) {\r\n                const taskWithTime = ensureNotFalsy(openTasks.shift());\r\n                /**\r\n                 * If the task came in before the last time the initial sync fetching\r\n                 * has run, we can ignore the task because the initial sync already processed\r\n                 * these documents.\r\n                 */\r\n                if (taskWithTime.time < initialSyncStartTime) {\r\n                    continue;\r\n                }\r\n                appendToArray(\r\n                    docs,\r\n                    taskWithTime.task.events.map(r => {\r\n                        return r.documentData as any;\r\n                    })\r\n                );\r\n                checkpoint = stackCheckpoints([checkpoint, taskWithTime.task.checkpoint]);\r\n            }\r\n\r\n            const promise = docs.length === 0 ? PROMISE_RESOLVE_FALSE : persistToMaster(\r\n                docs,\r\n                checkpoint\r\n            );\r\n            return promise.then(() => {\r\n                if (openTasks.length === 0) {\r\n                    state.events.active.up.next(false);\r\n                } else {\r\n                    scheduleProcessTasks();\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Returns true if had conflicts,\r\n     * false if not.\r\n     */\r\n    function persistToMaster(\r\n        docs: RxDocumentData<RxDocType>[],\r\n        checkpoint: CheckpointType\r\n    ): Promise<boolean> {\r\n        state.stats.up.persistToMaster = state.stats.up.persistToMaster + 1;\r\n\r\n        /**\r\n         * Add the new docs to the non-persistent list\r\n         */\r\n        docs.forEach(docData => {\r\n            const docId: string = (docData as any)[state.primaryPath];\r\n            nonPersistedFromMaster.docs[docId] = docData;\r\n        });\r\n        nonPersistedFromMaster.checkpoint = checkpoint;\r\n\r\n        persistenceQueue = persistenceQueue.then(async () => {\r\n            if (state.events.canceled.getValue()) {\r\n                return false;\r\n            }\r\n\r\n            const upDocsById: ById<RxDocumentData<RxDocType>> = nonPersistedFromMaster.docs;\r\n            nonPersistedFromMaster.docs = {};\r\n            const useCheckpoint = nonPersistedFromMaster.checkpoint;\r\n            const docIds = Object.keys(upDocsById);\r\n            if (docIds.length === 0) {\r\n                return false;\r\n            }\r\n\r\n            const assumedMasterState = await getAssumedMasterState(\r\n                state,\r\n                docIds\r\n            );\r\n\r\n            const writeRowsToMaster: ById<RxReplicationWriteToMasterRow<RxDocType>> = {};\r\n            const writeRowsToMasterIds: string[] = [];\r\n            const writeRowsToMeta: BulkWriteRowById<RxStorageReplicationMeta<RxDocType, any>> = {};\r\n            const forkStateById: ById<RxDocumentData<RxDocType>> = {};\r\n\r\n            await Promise.all(\r\n                docIds.map(async (docId) => {\r\n                    const fullDocData: RxDocumentData<RxDocType> = upDocsById[docId];\r\n                    forkStateById[docId] = fullDocData;\r\n                    const docData: WithDeleted<RxDocType> = writeDocToDocState(fullDocData, state.hasAttachments, !!state.input.keepMeta);\r\n                    const assumedMasterDoc = assumedMasterState[docId];\r\n\r\n                    /**\r\n                     * If the master state is equal to the\r\n                     * fork state, we can assume that the document state is already\r\n                     * replicated.\r\n                     */\r\n                    if (\r\n                        (\r\n                            assumedMasterDoc &&\r\n                            // if the isResolvedConflict is correct, we do not have to compare the documents.\r\n                            assumedMasterDoc.metaDocument.isResolvedConflict !== fullDocData._rev\r\n                            &&\r\n                            (await state.input.conflictHandler({\r\n                                realMasterState: assumedMasterDoc.docData,\r\n                                newDocumentState: docData\r\n                            }, 'upstream-check-if-equal')).isEqual\r\n                        )\r\n                        ||\r\n                        /**\r\n                         * If the master works with _rev fields,\r\n                         * we use that to check if our current doc state\r\n                         * is different from the assumedMasterDoc.\r\n                         */\r\n                        (\r\n                            assumedMasterDoc &&\r\n                            (assumedMasterDoc.docData as any)._rev &&\r\n                            parseRevision(fullDocData._rev).height === fullDocData._meta[state.input.identifier]\r\n                        )\r\n                    ) {\r\n                        return;\r\n                    }\r\n\r\n                    writeRowsToMasterIds.push(docId);\r\n\r\n                    writeRowsToMaster[docId] = {\r\n                        assumedMasterState: assumedMasterDoc ? assumedMasterDoc.docData : undefined,\r\n                        newDocumentState: docData\r\n                    };\r\n                    writeRowsToMeta[docId] = await getMetaWriteRow(\r\n                        state,\r\n                        docData,\r\n                        assumedMasterDoc ? assumedMasterDoc.metaDocument : undefined\r\n                    );\r\n                })\r\n            );\r\n\r\n            if (writeRowsToMasterIds.length === 0) {\r\n                return false;\r\n            }\r\n\r\n\r\n            const writeRowsArray = Object.values(writeRowsToMaster);\r\n            const conflictIds: Set<string> = new Set();\r\n            const conflictsById: ById<WithDeleted<RxDocType>> = {};\r\n\r\n            /**\r\n             * To always respect the push.batchSize,\r\n             * we have to split the write rows into batches\r\n             * to ensure that replicationHandler.masterWrite() is never\r\n             * called with more documents than what the batchSize limits.\r\n             */\r\n            const writeBatches = batchArray(writeRowsArray, state.input.pushBatchSize);\r\n            await Promise.all(\r\n                writeBatches.map(async (writeBatch) => {\r\n\r\n                    // enhance docs with attachments\r\n                    if (state.hasAttachments) {\r\n                        await Promise.all(\r\n                            writeBatch.map(async (row) => {\r\n                                row.newDocumentState = await fillWriteDataForAttachmentsChange(\r\n                                    state.primaryPath,\r\n                                    state.input.forkInstance,\r\n                                    clone(row.newDocumentState),\r\n                                    row.assumedMasterState\r\n                                );\r\n                            })\r\n                        );\r\n                    }\r\n                    const masterWriteResult = await replicationHandler.masterWrite(writeBatch);\r\n                    masterWriteResult.forEach(conflictDoc => {\r\n                        const id = (conflictDoc as any)[state.primaryPath];\r\n                        conflictIds.add(id);\r\n                        conflictsById[id] = conflictDoc;\r\n                    });\r\n                })\r\n            );\r\n\r\n            const useWriteRowsToMeta: BulkWriteRow<RxStorageReplicationMeta<RxDocType, any>>[] = [];\r\n\r\n            writeRowsToMasterIds.forEach(docId => {\r\n                if (!conflictIds.has(docId)) {\r\n                    state.events.processed.up.next(writeRowsToMaster[docId]);\r\n                    useWriteRowsToMeta.push(writeRowsToMeta[docId]);\r\n                }\r\n            });\r\n\r\n            if (state.events.canceled.getValue()) {\r\n                return false;\r\n            }\r\n\r\n            if (useWriteRowsToMeta.length > 0) {\r\n                await state.input.metaInstance.bulkWrite(\r\n                    stripAttachmentsDataFromMetaWriteRows(state, useWriteRowsToMeta),\r\n                    'replication-up-write-meta'\r\n                );\r\n                // TODO what happens when we have conflicts here?\r\n            }\r\n\r\n            /**\r\n             * Resolve conflicts by writing a new document\r\n             * state to the fork instance and the 'real' master state\r\n             * to the meta instance.\r\n             * Non-409 errors will be detected by resolveConflictError()\r\n             */\r\n            let hadConflictWrites = false;\r\n            if (conflictIds.size > 0) {\r\n                state.stats.up.persistToMasterHadConflicts = state.stats.up.persistToMasterHadConflicts + 1;\r\n                const conflictWriteFork: BulkWriteRow<RxDocType>[] = [];\r\n                const conflictWriteMeta: BulkWriteRowById<RxStorageReplicationMeta<RxDocType, any>> = {};\r\n                await Promise.all(\r\n                    Object\r\n                        .entries(conflictsById)\r\n                        .map(([docId, realMasterState]) => {\r\n                            const writeToMasterRow = writeRowsToMaster[docId];\r\n                            const input = {\r\n                                newDocumentState: writeToMasterRow.newDocumentState,\r\n                                assumedMasterState: writeToMasterRow.assumedMasterState,\r\n                                realMasterState\r\n                            };\r\n                            return resolveConflictError(\r\n                                state,\r\n                                input,\r\n                                forkStateById[docId]\r\n                            ).then(async (resolved) => {\r\n                                if (resolved) {\r\n                                    state.events.resolvedConflicts.next({\r\n                                        input,\r\n                                        output: resolved.output\r\n                                    });\r\n                                    conflictWriteFork.push({\r\n                                        previous: forkStateById[docId],\r\n                                        document: resolved.resolvedDoc\r\n                                    });\r\n                                    const assumedMasterDoc = assumedMasterState[docId];\r\n                                    conflictWriteMeta[docId] = await getMetaWriteRow(\r\n                                        state,\r\n                                        ensureNotFalsy(realMasterState),\r\n                                        assumedMasterDoc ? assumedMasterDoc.metaDocument : undefined,\r\n                                        resolved.resolvedDoc._rev\r\n                                    );\r\n                                }\r\n                            });\r\n                        })\r\n                );\r\n\r\n                if (conflictWriteFork.length > 0) {\r\n                    hadConflictWrites = true;\r\n\r\n                    state.stats.up.persistToMasterConflictWrites = state.stats.up.persistToMasterConflictWrites + 1;\r\n                    const forkWriteResult = await state.input.forkInstance.bulkWrite(\r\n                        conflictWriteFork,\r\n                        'replication-up-write-conflict'\r\n                    );\r\n                    /**\r\n                     * Errors in the forkWriteResult must not be handled\r\n                     * because they have been caused by a write to the forkInstance\r\n                     * in between which will anyway trigger a new upstream cycle\r\n                     * that will then resolved the conflict again.\r\n                     */\r\n                    const useMetaWrites: BulkWriteRow<RxStorageReplicationMeta<RxDocType, any>>[] = [];\r\n                    forkWriteResult.success\r\n                        .forEach(docData => {\r\n                            const docId = (docData as any)[state.primaryPath];\r\n                            useMetaWrites.push(\r\n                                conflictWriteMeta[docId]\r\n                            );\r\n                        });\r\n                    if (useMetaWrites.length > 0) {\r\n                        await state.input.metaInstance.bulkWrite(\r\n                            stripAttachmentsDataFromMetaWriteRows(state, useMetaWrites),\r\n                            'replication-up-write-conflict-meta'\r\n                        );\r\n                    }\r\n                    // TODO what to do with conflicts while writing to the metaInstance?\r\n                }\r\n            }\r\n\r\n            /**\r\n             * For better performance we do not await checkpoint writes,\r\n             * but to ensure order on parallel checkpoint writes,\r\n             * we have to use a queue.\r\n             */\r\n            setCheckpoint(\r\n                state,\r\n                'up',\r\n                useCheckpoint\r\n            );\r\n\r\n            return hadConflictWrites;\r\n        }).catch(unhandledError => {\r\n            state.events.error.next(unhandledError);\r\n            return false;\r\n        });\r\n\r\n        return persistenceQueue;\r\n    }\r\n}\r\n"],"mappings":";;;;;;AAAA,IAAAA,KAAA,GAAAC,OAAA;AACA,IAAAC,gBAAA,GAAAD,OAAA;AAgBA,IAAAE,MAAA,GAAAF,OAAA;AAQA,IAAAG,WAAA,GAAAH,OAAA;AAIA,IAAAI,UAAA,GAAAJ,OAAA;AAGA,IAAAK,OAAA,GAAAL,OAAA;AAIA,IAAAM,aAAA,GAAAN,OAAA;AAIA,IAAAO,OAAA,GAAAP,OAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,eAAeQ,wBAAwBA,CAC1CC,KAAmD,EACrD;EACE,IACIA,KAAK,CAACC,KAAK,CAACC,iBAAiB,IAC7BF,KAAK,CAACC,KAAK,CAACC,iBAAiB,CAACC,QAAQ,EACxC;IACE,IAAMC,aAAa,GAAG,MAAM,IAAAC,gCAAoB,EAACL,KAAK,EAAE,IAAI,CAAC;IAC7D,IAAI,CAACI,aAAa,EAAE;MAChB,MAAM,IAAAE,yBAAa,EACfN,KAAK,EACL,IAAI,EACJA,KAAK,CAACC,KAAK,CAACC,iBAAiB,CAACC,QAClC,CAAC;IACL;EACJ;EAEA,IAAMI,kBAAkB,GAAGP,KAAK,CAACC,KAAK,CAACM,kBAAkB;EACzDP,KAAK,CAACQ,WAAW,CAACC,EAAE,GAAGT,KAAK,CAACQ,WAAW,CAACC,EAAE,CAACC,IAAI,CAAC,MAAM;IACnD,OAAOC,mBAAmB,CAAC,CAAC,CAACD,IAAI,CAAC,MAAM;MACpCE,YAAY,CAAC,CAAC;IAClB,CAAC,CAAC;EACN,CAAC,CAAC;;EAEF;EACA,IAAIC,KAAK,GAAG,CAAC;EACb,IAAIC,oBAAoB,GAAG,CAAC,CAAC;EAC7B,IAAIC,WAAoB,GAAG,KAAK;EAOhC,IAAMC,SAAyB,GAAG,EAAE;EACpC,IAAIC,gBAAkC,GAAGC,4BAAqB;EAC9D,IAAMC,sBAGL,GAAG;IACAC,IAAI,EAAE,CAAC;EACX,CAAC;EAED,IAAMC,GAAG,GAAGrB,KAAK,CAACC,KAAK,CAACqB,YAAY,CAACC,YAAY,CAAC,CAAC,CAC9CC,SAAS,CAAC,MAAOC,SAAS,IAAK;IAC5B;IACA,IAAIA,SAAS,CAACC,OAAO,MAAK,MAAM1B,KAAK,CAAC2B,uBAAuB,GAAE;MAC3D;IACJ;IAEA3B,KAAK,CAAC4B,KAAK,CAACnB,EAAE,CAACoB,oBAAoB,GAAG7B,KAAK,CAAC4B,KAAK,CAACnB,EAAE,CAACoB,oBAAoB,GAAG,CAAC;IAC7Eb,SAAS,CAACc,IAAI,CAAC;MACXC,IAAI,EAAEN,SAAS;MACfO,IAAI,EAAEnB,KAAK;IACf,CAAC,CAAC;IACF,IAAI,CAACb,KAAK,CAACiC,MAAM,CAACC,MAAM,CAACzB,EAAE,CAAC0B,QAAQ,CAAC,CAAC,EAAE;MACpCnC,KAAK,CAACiC,MAAM,CAACC,MAAM,CAACzB,EAAE,CAAC2B,IAAI,CAAC,IAAI,CAAC;IACrC;IACA,OAAOC,oBAAoB,CAAC,CAAC;EACjC,CAAC,CAAC;EACN,IAAAC,oBAAc,EACVtC,KAAK,CAACiC,MAAM,CAACM,QAAQ,CAACC,IAAI,CACtB,IAAAC,YAAM,EAACF,QAAQ,IAAI,CAAC,CAACA,QAAQ,CACjC,CACJ,CAAC,CAAC7B,IAAI,CAAC,MAAMW,GAAG,CAACqB,WAAW,CAAC,CAAC,CAAC;EAE/B,SAASL,oBAAoBA,CAAA,EAAG;IAC5B,IAAI,CAACtB,WAAW,EAAE;MACd;MACAA,WAAW,GAAG,IAAI;MAClB,IAAIf,KAAK,CAACC,KAAK,CAAC0C,iBAAiB,EAAE;QAC/B,OAAO3C,KAAK,CAACC,KAAK,CAAC0C,iBAAiB,CAAC,CAAC,CACjCjC,IAAI,CAAC,MAAME,YAAY,CAAC,CAAC,CAAC;MACnC,CAAC,MAAM;QACH,OAAOA,YAAY,CAAC,CAAC;MACzB;IACJ;EACJ;EAEA,eAAeD,mBAAmBA,CAAA,EAAG;IACjCX,KAAK,CAAC4B,KAAK,CAACnB,EAAE,CAACE,mBAAmB,GAAGX,KAAK,CAAC4B,KAAK,CAACnB,EAAE,CAACE,mBAAmB,GAAG,CAAC;IAC3E,IAAIX,KAAK,CAACiC,MAAM,CAACM,QAAQ,CAACJ,QAAQ,CAAC,CAAC,EAAE;MAClC;IACJ;IAEAnC,KAAK,CAAC4C,eAAe,GAAG5C,KAAK,CAAC4C,eAAe,CAAClC,IAAI,CAAC,MAAM,IAAAL,gCAAoB,EAACL,KAAK,EAAE,IAAI,CAAC,CAAC;IAC3F,IAAI6C,cAA8B,GAAG,MAAM7C,KAAK,CAAC4C,eAAe;IAEhE,IAAME,QAA2B,GAAG,IAAIC,GAAG,CAAC,CAAC;IAAC,IAAAC,KAAA,kBAAAA,CAAA,EAEJ;MACtClC,oBAAoB,GAAGD,KAAK,EAAE;;MAE9B;AACZ;AACA;AACA;AACA;AACA;AACA;MACY,IAAIiC,QAAQ,CAACG,IAAI,GAAG,CAAC,EAAE;QACnB,MAAMC,OAAO,CAACC,IAAI,CAACC,KAAK,CAACC,IAAI,CAACP,QAAQ,CAAC,CAAC;MAC5C;MAEA,IAAMQ,QAAQ,GAAG,MAAM,IAAAC,yCAAwB,EAC3CvD,KAAK,CAACC,KAAK,CAACqB,YAAY,EACxBtB,KAAK,CAACC,KAAK,CAACuD,aAAa,EACzBX,cACJ,CAAC;MACD,IAAIS,QAAQ,CAACG,SAAS,CAACC,MAAM,KAAK,CAAC,EAAE;QAAA;MAErC;MAEAb,cAAc,GAAG,IAAAc,iCAAgB,EAAC,CAACd,cAAc,EAAES,QAAQ,CAACM,UAAU,CAAC,CAAC;MAExE,IAAMC,OAAO,GAAGC,eAAe,CAC3BR,QAAQ,CAACG,SAAS,EAClB,IAAAM,qBAAc,EAAClB,cAAc,CACjC,CAAC;MACDC,QAAQ,CAACkB,GAAG,CAACH,OAAO,CAAC;MACrBA,OAAO,CAACI,KAAK,CAAC,CAAC,CAACvD,IAAI,CAAC,MAAMoC,QAAQ,CAACoB,MAAM,CAACL,OAAO,CAAC,CAAC;IACxD,CAAC;IA/BD,OAAO,CAAC7D,KAAK,CAACiC,MAAM,CAACM,QAAQ,CAACJ,QAAQ,CAAC,CAAC;MAAA,UAAAa,KAAA,IAoBhC;IAAM;;IAad;AACR;AACA;AACA;AACA;IACQ,IAAMmB,gBAAgB,GAAG,MAAMjB,OAAO,CAACkB,GAAG,CAACtB,QAAQ,CAAC;IACpD,IAAMuB,YAAY,GAAGF,gBAAgB,CAACG,IAAI,CAACC,CAAC,IAAI,CAAC,CAACA,CAAC,CAAC;IACpD,IAAIF,YAAY,EAAE;MACd,MAAM1D,mBAAmB,CAAC,CAAC;IAC/B,CAAC,MAAM,IACH,CAACX,KAAK,CAACwE,aAAa,CAAC/D,EAAE,CAAC0B,QAAQ,CAAC,CAAC,IAClC,CAACnC,KAAK,CAACiC,MAAM,CAACM,QAAQ,CAACJ,QAAQ,CAAC,CAAC,EACnC;MACEnC,KAAK,CAACwE,aAAa,CAAC/D,EAAE,CAAC2B,IAAI,CAAC,IAAI,CAAC;IACrC;EACJ;;EAGA;AACJ;AACA;EACI,SAASxB,YAAYA,CAAA,EAAG;IACpBG,WAAW,GAAG,KAAK;IACnB,IACIf,KAAK,CAACiC,MAAM,CAACM,QAAQ,CAACJ,QAAQ,CAAC,CAAC,IAChCnB,SAAS,CAAC0C,MAAM,KAAK,CAAC,EACxB;MACE1D,KAAK,CAACiC,MAAM,CAACC,MAAM,CAACzB,EAAE,CAAC2B,IAAI,CAAC,KAAK,CAAC;MAClC;IACJ;IACApC,KAAK,CAAC4B,KAAK,CAACnB,EAAE,CAACG,YAAY,GAAGZ,KAAK,CAAC4B,KAAK,CAACnB,EAAE,CAACG,YAAY,GAAG,CAAC;IAC7DZ,KAAK,CAACiC,MAAM,CAACC,MAAM,CAACzB,EAAE,CAAC2B,IAAI,CAAC,IAAI,CAAC;IACjCpC,KAAK,CAACQ,WAAW,CAACC,EAAE,GAAGT,KAAK,CAACQ,WAAW,CAACC,EAAE,CAACC,IAAI,CAAC,MAAM;MACnD;AACZ;AACA;MACY,IAAMU,IAAiC,GAAG,EAAE;MAC5C,IAAIwC,UAA0B,GAAG,CAAC,CAAQ;MAC1C,OAAO5C,SAAS,CAAC0C,MAAM,GAAG,CAAC,EAAE;QACzB,IAAMe,YAAY,GAAG,IAAAV,qBAAc,EAAC/C,SAAS,CAAC0D,KAAK,CAAC,CAAC,CAAC;QACtD;AAChB;AACA;AACA;AACA;QACgB,IAAID,YAAY,CAACzC,IAAI,GAAGlB,oBAAoB,EAAE;UAC1C;QACJ;QACA,IAAA6D,oBAAa,EACTvD,IAAI,EACJqD,YAAY,CAAC1C,IAAI,CAACE,MAAM,CAAC2C,GAAG,CAACL,CAAC,IAAI;UAC9B,OAAOA,CAAC,CAACM,YAAY;QACzB,CAAC,CACL,CAAC;QACDjB,UAAU,GAAG,IAAAD,iCAAgB,EAAC,CAACC,UAAU,EAAEa,YAAY,CAAC1C,IAAI,CAAC6B,UAAU,CAAC,CAAC;MAC7E;MAEA,IAAMC,OAAO,GAAGzC,IAAI,CAACsC,MAAM,KAAK,CAAC,GAAGxC,4BAAqB,GAAG4C,eAAe,CACvE1C,IAAI,EACJwC,UACJ,CAAC;MACD,OAAOC,OAAO,CAACnD,IAAI,CAAC,MAAM;QACtB,IAAIM,SAAS,CAAC0C,MAAM,KAAK,CAAC,EAAE;UACxB1D,KAAK,CAACiC,MAAM,CAACC,MAAM,CAACzB,EAAE,CAAC2B,IAAI,CAAC,KAAK,CAAC;QACtC,CAAC,MAAM;UACHC,oBAAoB,CAAC,CAAC;QAC1B;MACJ,CAAC,CAAC;IACN,CAAC,CAAC;EACN;;EAEA;AACJ;AACA;AACA;EACI,SAASyB,eAAeA,CACpB1C,IAAiC,EACjCwC,UAA0B,EACV;IAChB5D,KAAK,CAAC4B,KAAK,CAACnB,EAAE,CAACqD,eAAe,GAAG9D,KAAK,CAAC4B,KAAK,CAACnB,EAAE,CAACqD,eAAe,GAAG,CAAC;;IAEnE;AACR;AACA;IACQ1C,IAAI,CAAC0D,OAAO,CAACC,OAAO,IAAI;MACpB,IAAMC,KAAa,GAAID,OAAO,CAAS/E,KAAK,CAACiF,WAAW,CAAC;MACzD9D,sBAAsB,CAACC,IAAI,CAAC4D,KAAK,CAAC,GAAGD,OAAO;IAChD,CAAC,CAAC;IACF5D,sBAAsB,CAACyC,UAAU,GAAGA,UAAU;IAE9C3C,gBAAgB,GAAGA,gBAAgB,CAACP,IAAI,CAAC,YAAY;MACjD,IAAIV,KAAK,CAACiC,MAAM,CAACM,QAAQ,CAACJ,QAAQ,CAAC,CAAC,EAAE;QAClC,OAAO,KAAK;MAChB;MAEA,IAAM+C,UAA2C,GAAG/D,sBAAsB,CAACC,IAAI;MAC/ED,sBAAsB,CAACC,IAAI,GAAG,CAAC,CAAC;MAChC,IAAM+D,aAAa,GAAGhE,sBAAsB,CAACyC,UAAU;MACvD,IAAMwB,MAAM,GAAGC,MAAM,CAACC,IAAI,CAACJ,UAAU,CAAC;MACtC,IAAIE,MAAM,CAAC1B,MAAM,KAAK,CAAC,EAAE;QACrB,OAAO,KAAK;MAChB;MAEA,IAAM6B,kBAAkB,GAAG,MAAM,IAAAC,mCAAqB,EAClDxF,KAAK,EACLoF,MACJ,CAAC;MAED,IAAMK,iBAAiE,GAAG,CAAC,CAAC;MAC5E,IAAMC,oBAA8B,GAAG,EAAE;MACzC,IAAMC,eAA2E,GAAG,CAAC,CAAC;MACtF,IAAMC,aAA8C,GAAG,CAAC,CAAC;MAEzD,MAAM1C,OAAO,CAACkB,GAAG,CACbgB,MAAM,CAACR,GAAG,CAAC,MAAOI,KAAK,IAAK;QACxB,IAAMa,WAAsC,GAAGX,UAAU,CAACF,KAAK,CAAC;QAChEY,aAAa,CAACZ,KAAK,CAAC,GAAGa,WAAW;QAClC,IAAMd,OAA+B,GAAG,IAAAe,0BAAkB,EAACD,WAAW,EAAE7F,KAAK,CAAC+F,cAAc,EAAE,CAAC,CAAC/F,KAAK,CAACC,KAAK,CAAC+F,QAAQ,CAAC;QACrH,IAAMC,gBAAgB,GAAGV,kBAAkB,CAACP,KAAK,CAAC;;QAElD;AACpB;AACA;AACA;AACA;QACoB,IAEQiB,gBAAgB;QAChB;QACAA,gBAAgB,CAACC,YAAY,CAACC,kBAAkB,KAAKN,WAAW,CAACO,IAAI,IAErE,CAAC,MAAMpG,KAAK,CAACC,KAAK,CAACoG,eAAe,CAAC;UAC/BC,eAAe,EAAEL,gBAAgB,CAAClB,OAAO;UACzCwB,gBAAgB,EAAExB;QACtB,CAAC,EAAE,yBAAyB,CAAC,EAAEyB,OAAO;QAG1C;AACxB;AACA;AACA;AACA;;QAE4BP,gBAAgB,IACfA,gBAAgB,CAAClB,OAAO,CAASqB,IAAI,IACtC,IAAAK,oBAAa,EAACZ,WAAW,CAACO,IAAI,CAAC,CAACM,MAAM,KAAKb,WAAW,CAACc,KAAK,CAAC3G,KAAK,CAACC,KAAK,CAAC2G,UAAU,CAAC,CACvF,EACH;UACE;QACJ;QAEAlB,oBAAoB,CAAC5D,IAAI,CAACkD,KAAK,CAAC;QAEhCS,iBAAiB,CAACT,KAAK,CAAC,GAAG;UACvBO,kBAAkB,EAAEU,gBAAgB,GAAGA,gBAAgB,CAAClB,OAAO,GAAG8B,SAAS;UAC3EN,gBAAgB,EAAExB;QACtB,CAAC;QACDY,eAAe,CAACX,KAAK,CAAC,GAAG,MAAM,IAAA8B,6BAAe,EAC1C9G,KAAK,EACL+E,OAAO,EACPkB,gBAAgB,GAAGA,gBAAgB,CAACC,YAAY,GAAGW,SACvD,CAAC;MACL,CAAC,CACL,CAAC;MAED,IAAInB,oBAAoB,CAAChC,MAAM,KAAK,CAAC,EAAE;QACnC,OAAO,KAAK;MAChB;MAGA,IAAMqD,cAAc,GAAG1B,MAAM,CAAC2B,MAAM,CAACvB,iBAAiB,CAAC;MACvD,IAAMwB,WAAwB,GAAG,IAAIlE,GAAG,CAAC,CAAC;MAC1C,IAAMmE,aAA2C,GAAG,CAAC,CAAC;;MAEtD;AACZ;AACA;AACA;AACA;AACA;MACY,IAAMC,YAAY,GAAG,IAAAC,iBAAU,EAACL,cAAc,EAAE/G,KAAK,CAACC,KAAK,CAACuD,aAAa,CAAC;MAC1E,MAAMN,OAAO,CAACkB,GAAG,CACb+C,YAAY,CAACvC,GAAG,CAAC,MAAOyC,UAAU,IAAK;QAEnC;QACA,IAAIrH,KAAK,CAAC+F,cAAc,EAAE;UACtB,MAAM7C,OAAO,CAACkB,GAAG,CACbiD,UAAU,CAACzC,GAAG,CAAC,MAAO0C,GAAG,IAAK;YAC1BA,GAAG,CAACf,gBAAgB,GAAG,MAAM,IAAAgB,yCAAiC,EAC1DvH,KAAK,CAACiF,WAAW,EACjBjF,KAAK,CAACC,KAAK,CAACqB,YAAY,EACxB,IAAAkG,YAAK,EAACF,GAAG,CAACf,gBAAgB,CAAC,EAC3Be,GAAG,CAAC/B,kBACR,CAAC;UACL,CAAC,CACL,CAAC;QACL;QACA,IAAMkC,iBAAiB,GAAG,MAAMlH,kBAAkB,CAACmH,WAAW,CAACL,UAAU,CAAC;QAC1EI,iBAAiB,CAAC3C,OAAO,CAAC6C,WAAW,IAAI;UACrC,IAAMC,EAAE,GAAID,WAAW,CAAS3H,KAAK,CAACiF,WAAW,CAAC;UAClDgC,WAAW,CAACjD,GAAG,CAAC4D,EAAE,CAAC;UACnBV,aAAa,CAACU,EAAE,CAAC,GAAGD,WAAW;QACnC,CAAC,CAAC;MACN,CAAC,CACL,CAAC;MAED,IAAME,kBAA4E,GAAG,EAAE;MAEvFnC,oBAAoB,CAACZ,OAAO,CAACE,KAAK,IAAI;QAClC,IAAI,CAACiC,WAAW,CAACa,GAAG,CAAC9C,KAAK,CAAC,EAAE;UACzBhF,KAAK,CAACiC,MAAM,CAAC8F,SAAS,CAACtH,EAAE,CAAC2B,IAAI,CAACqD,iBAAiB,CAACT,KAAK,CAAC,CAAC;UACxD6C,kBAAkB,CAAC/F,IAAI,CAAC6D,eAAe,CAACX,KAAK,CAAC,CAAC;QACnD;MACJ,CAAC,CAAC;MAEF,IAAIhF,KAAK,CAACiC,MAAM,CAACM,QAAQ,CAACJ,QAAQ,CAAC,CAAC,EAAE;QAClC,OAAO,KAAK;MAChB;MAEA,IAAI0F,kBAAkB,CAACnE,MAAM,GAAG,CAAC,EAAE;QAC/B,MAAM1D,KAAK,CAACC,KAAK,CAAC+H,YAAY,CAACC,SAAS,CACpC,IAAAC,6CAAqC,EAAClI,KAAK,EAAE6H,kBAAkB,CAAC,EAChE,2BACJ,CAAC;QACD;MACJ;;MAEA;AACZ;AACA;AACA;AACA;AACA;MACY,IAAIM,iBAAiB,GAAG,KAAK;MAC7B,IAAIlB,WAAW,CAAChE,IAAI,GAAG,CAAC,EAAE;QACtBjD,KAAK,CAAC4B,KAAK,CAACnB,EAAE,CAAC2H,2BAA2B,GAAGpI,KAAK,CAAC4B,KAAK,CAACnB,EAAE,CAAC2H,2BAA2B,GAAG,CAAC;QAC3F,IAAMC,iBAA4C,GAAG,EAAE;QACvD,IAAMC,iBAA6E,GAAG,CAAC,CAAC;QACxF,MAAMpF,OAAO,CAACkB,GAAG,CACbiB,MAAM,CACDkD,OAAO,CAACrB,aAAa,CAAC,CACtBtC,GAAG,CAAC,CAAC,CAACI,KAAK,EAAEsB,eAAe,CAAC,KAAK;UAC/B,IAAMkC,gBAAgB,GAAG/C,iBAAiB,CAACT,KAAK,CAAC;UACjD,IAAM/E,KAAK,GAAG;YACVsG,gBAAgB,EAAEiC,gBAAgB,CAACjC,gBAAgB;YACnDhB,kBAAkB,EAAEiD,gBAAgB,CAACjD,kBAAkB;YACvDe;UACJ,CAAC;UACD,OAAO,IAAAmC,+BAAoB,EACvBzI,KAAK,EACLC,KAAK,EACL2F,aAAa,CAACZ,KAAK,CACvB,CAAC,CAACtE,IAAI,CAAC,MAAOgI,QAAQ,IAAK;YACvB,IAAIA,QAAQ,EAAE;cACV1I,KAAK,CAACiC,MAAM,CAAC0G,iBAAiB,CAACvG,IAAI,CAAC;gBAChCnC,KAAK;gBACL2I,MAAM,EAAEF,QAAQ,CAACE;cACrB,CAAC,CAAC;cACFP,iBAAiB,CAACvG,IAAI,CAAC;gBACnB+G,QAAQ,EAAEjD,aAAa,CAACZ,KAAK,CAAC;gBAC9B8D,QAAQ,EAAEJ,QAAQ,CAACK;cACvB,CAAC,CAAC;cACF,IAAM9C,gBAAgB,GAAGV,kBAAkB,CAACP,KAAK,CAAC;cAClDsD,iBAAiB,CAACtD,KAAK,CAAC,GAAG,MAAM,IAAA8B,6BAAe,EAC5C9G,KAAK,EACL,IAAA+D,qBAAc,EAACuC,eAAe,CAAC,EAC/BL,gBAAgB,GAAGA,gBAAgB,CAACC,YAAY,GAAGW,SAAS,EAC5D6B,QAAQ,CAACK,WAAW,CAAC3C,IACzB,CAAC;YACL;UACJ,CAAC,CAAC;QACN,CAAC,CACT,CAAC;QAED,IAAIiC,iBAAiB,CAAC3E,MAAM,GAAG,CAAC,EAAE;UAC9ByE,iBAAiB,GAAG,IAAI;UAExBnI,KAAK,CAAC4B,KAAK,CAACnB,EAAE,CAACuI,6BAA6B,GAAGhJ,KAAK,CAAC4B,KAAK,CAACnB,EAAE,CAACuI,6BAA6B,GAAG,CAAC;UAC/F,IAAMC,eAAe,GAAG,MAAMjJ,KAAK,CAACC,KAAK,CAACqB,YAAY,CAAC2G,SAAS,CAC5DI,iBAAiB,EACjB,+BACJ,CAAC;UACD;AACpB;AACA;AACA;AACA;AACA;UACoB,IAAMa,aAAuE,GAAG,EAAE;UAClFD,eAAe,CAACE,OAAO,CAClBrE,OAAO,CAACC,OAAO,IAAI;YAChB,IAAMC,KAAK,GAAID,OAAO,CAAS/E,KAAK,CAACiF,WAAW,CAAC;YACjDiE,aAAa,CAACpH,IAAI,CACdwG,iBAAiB,CAACtD,KAAK,CAC3B,CAAC;UACL,CAAC,CAAC;UACN,IAAIkE,aAAa,CAACxF,MAAM,GAAG,CAAC,EAAE;YAC1B,MAAM1D,KAAK,CAACC,KAAK,CAAC+H,YAAY,CAACC,SAAS,CACpC,IAAAC,6CAAqC,EAAClI,KAAK,EAAEkJ,aAAa,CAAC,EAC3D,oCACJ,CAAC;UACL;UACA;QACJ;MACJ;;MAEA;AACZ;AACA;AACA;AACA;MACY,IAAA5I,yBAAa,EACTN,KAAK,EACL,IAAI,EACJmF,aACJ,CAAC;MAED,OAAOgD,iBAAiB;IAC5B,CAAC,CAAC,CAAClE,KAAK,CAACmF,cAAc,IAAI;MACvBpJ,KAAK,CAACiC,MAAM,CAACoH,KAAK,CAACjH,IAAI,CAACgH,cAAc,CAAC;MACvC,OAAO,KAAK;IAChB,CAAC,CAAC;IAEF,OAAOnI,gBAAgB;EAC3B;AACJ","ignoreList":[]}