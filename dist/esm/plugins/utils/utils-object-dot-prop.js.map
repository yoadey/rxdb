{"version":3,"file":"utils-object-dot-prop.js","names":["isObject","value","type","disallowedKeys","Set","digits","getPathSegments","path","parts","currentSegment","currentPart","isIgnoring","character","Error","has","push","Number","parseInt","isStringIndex","object","key","Array","isArray","index","isInteger","assertNotStringIndex","getProperty","join","includes","undefined","pathArray","length","setProperty","root","deleteProperty","hasProperty","escapePath","TypeError","replace","entries","map","v","Object","stringifyPath","pathSegments","result","segment","deepKeysIterator","currentPath","deepKeys"],"sources":["../../../../src/plugins/utils/utils-object-dot-prop.ts"],"sourcesContent":["/**\n * Copied from\n * @link https://github.com/sindresorhus/dot-prop/blob/main/index.js\n * because it is currently an esm only module.\n * TODO use the npm package again when RxDB is also fully esm.\n */\n\nconst isObject = (value: null) => {\n    const type = typeof value;\n    return value !== null && (type === 'object' || type === 'function');\n};\n\nconst disallowedKeys = new Set([\n    '__proto__',\n    'prototype',\n    'constructor',\n]);\n\nconst digits = new Set('0123456789');\n\nfunction getPathSegments(path: string) {\n    const parts = [];\n    let currentSegment = '';\n    let currentPart = 'start';\n    let isIgnoring = false;\n\n    for (const character of path) {\n        switch (character) {\n            case '\\\\': {\n                if (currentPart === 'index') {\n                    throw new Error('Invalid character in an index');\n                }\n\n                if (currentPart === 'indexEnd') {\n                    throw new Error('Invalid character after an index');\n                }\n\n                if (isIgnoring) {\n                    currentSegment += character;\n                }\n\n                currentPart = 'property';\n                isIgnoring = !isIgnoring;\n                break;\n            }\n\n            case '.': {\n                if (currentPart === 'index') {\n                    throw new Error('Invalid character in an index');\n                }\n\n                if (currentPart === 'indexEnd') {\n                    currentPart = 'property';\n                    break;\n                }\n\n                if (isIgnoring) {\n                    isIgnoring = false;\n                    currentSegment += character;\n                    break;\n                }\n\n                if (disallowedKeys.has(currentSegment)) {\n                    return [];\n                }\n\n                parts.push(currentSegment);\n                currentSegment = '';\n                currentPart = 'property';\n                break;\n            }\n\n            case '[': {\n                if (currentPart === 'index') {\n                    throw new Error('Invalid character in an index');\n                }\n\n                if (currentPart === 'indexEnd') {\n                    currentPart = 'index';\n                    break;\n                }\n\n                if (isIgnoring) {\n                    isIgnoring = false;\n                    currentSegment += character;\n                    break;\n                }\n\n                if (currentPart === 'property') {\n                    if (disallowedKeys.has(currentSegment)) {\n                        return [];\n                    }\n\n                    parts.push(currentSegment);\n                    currentSegment = '';\n                }\n\n                currentPart = 'index';\n                break;\n            }\n\n            case ']': {\n                if (currentPart === 'index') {\n                    parts.push(Number.parseInt(currentSegment, 10));\n                    currentSegment = '';\n                    currentPart = 'indexEnd';\n                    break;\n                }\n\n                if (currentPart === 'indexEnd') {\n                    throw new Error('Invalid character after an index');\n                }\n\n                // Falls through\n            }\n\n            default: {\n                if (currentPart === 'index' && !digits.has(character)) {\n                    throw new Error('Invalid character in an index');\n                }\n\n                if (currentPart === 'indexEnd') {\n                    throw new Error('Invalid character after an index');\n                }\n\n                if (currentPart === 'start') {\n                    currentPart = 'property';\n                }\n\n                if (isIgnoring) {\n                    isIgnoring = false;\n                    currentSegment += '\\\\';\n                }\n\n                currentSegment += character;\n            }\n        }\n    }\n\n    if (isIgnoring) {\n        currentSegment += '\\\\';\n    }\n\n    switch (currentPart) {\n        case 'property': {\n            if (disallowedKeys.has(currentSegment)) {\n                return [];\n            }\n\n            parts.push(currentSegment);\n\n            break;\n        }\n\n        case 'index': {\n            throw new Error('Index was not closed');\n        }\n\n        case 'start': {\n            parts.push('');\n\n            break;\n        }\n        // No default\n    }\n\n    return parts;\n}\n\nfunction isStringIndex(object: any[], key: string) {\n    if (typeof key !== 'number' && Array.isArray(object)) {\n        const index = Number.parseInt(key, 10);\n        return Number.isInteger(index) && object[index] === object[key as any];\n    }\n\n    return false;\n}\n\nfunction assertNotStringIndex(object: any, key: string | number) {\n    if (isStringIndex(object, key as any)) {\n        throw new Error('Cannot use string index');\n    }\n}\n\n/**\n * TODO we need some performance tests and improvements here.\n */\nexport function getProperty(object: any, path: string | string[], value?: any) {\n    if (Array.isArray(path)) {\n        path = path.join('.');\n    }\n\n    /**\n     * Performance shortcut.\n     * In most cases we just have a simple property name\n     * so we can directly return it.\n     */\n    if (\n        !path.includes('.') &&\n        !path.includes('[')\n    ) {\n        return object[path];\n    }\n\n    if (!isObject(object as any) || typeof path !== 'string') {\n        return value === undefined ? object : value;\n    }\n\n    const pathArray = getPathSegments(path);\n    if (pathArray.length === 0) {\n        return value;\n    }\n\n    for (let index = 0; index < pathArray.length; index++) {\n        const key = pathArray[index];\n\n        if (isStringIndex(object as any, key as any)) {\n            object = index === pathArray.length - 1 ? undefined : null;\n        } else {\n            object = (object as any)[key];\n        }\n\n        if (object === undefined || object === null) {\n            // `object` is either `undefined` or `null` so we want to stop the loop, and\n            // if this is not the last bit of the path, and\n            // if it didn't return `undefined`\n            // it would return `null` if `object` is `null`\n            // but we want `get({foo: null}, 'foo.bar')` to equal `undefined`, or the supplied value, not `null`\n            if (index !== pathArray.length - 1) {\n                return value;\n            }\n\n            break;\n        }\n    }\n\n    return object === undefined ? value : object;\n}\n\nexport function setProperty(object: any, path: string, value: any) {\n    if (Array.isArray(path)) {\n        path = path.join('.');\n    }\n\n    if (!isObject(object as any) || typeof path !== 'string') {\n        return object;\n    }\n\n    const root = object;\n    const pathArray = getPathSegments(path);\n\n    for (let index = 0; index < pathArray.length; index++) {\n        const key = pathArray[index];\n\n        assertNotStringIndex(object, key);\n\n        if (index === pathArray.length - 1) {\n            object[key] = value;\n        } else if (!isObject(object[key])) {\n            object[key] = typeof pathArray[index + 1] === 'number' ? [] : {};\n        }\n\n        object = object[key];\n    }\n\n    return root;\n}\n\nexport function deleteProperty(object: any, path: string) {\n    if (!isObject(object as any) || typeof path !== 'string') {\n        return false;\n    }\n\n    const pathArray = getPathSegments(path);\n\n    for (let index = 0; index < pathArray.length; index++) {\n        const key = pathArray[index];\n\n        assertNotStringIndex(object, key);\n\n        if (index === pathArray.length - 1) {\n            delete object[key];\n            return true;\n        }\n\n        object = object[key];\n\n        if (!isObject(object as any)) {\n            return false;\n        }\n    }\n}\n\nexport function hasProperty(object: any, path: string) {\n    if (!isObject(object) || typeof path !== 'string') {\n        return false;\n    }\n\n    const pathArray = getPathSegments(path);\n    if (pathArray.length === 0) {\n        return false;\n    }\n\n    for (const key of pathArray) {\n        if (!isObject(object) || !(key in object) || isStringIndex(object, key as any)) {\n            return false;\n        }\n\n        object = object[key];\n    }\n\n    return true;\n}\n\n// TODO: Backslashes with no effect should not be escaped\nfunction escapePath(path: string) {\n    if (typeof path !== 'string') {\n        throw new TypeError('Expected a string');\n    }\n\n    return path.replace(/[\\\\.[]/g, '\\\\$&');\n}\n\n// The keys returned by Object.entries() for arrays are strings\nfunction entries(value: any) {\n    if (Array.isArray(value)) {\n        return value.map((v, index) => [index, v]);\n    }\n\n    return Object.entries(value);\n}\n\nfunction stringifyPath(pathSegments: never[]) {\n    let result = '';\n\n    // eslint-disable-next-line prefer-const\n    for (let [index, segment] of entries(pathSegments)) {\n        if (typeof segment === 'number') {\n            result += `[${segment}]`;\n        } else {\n            segment = escapePath(segment);\n            result += index === 0 ? segment : `.${segment}`;\n        }\n    }\n\n    return result;\n}\n\nfunction* deepKeysIterator(object: any, currentPath = []): any {\n    if (!isObject(object)) {\n        if (currentPath.length > 0) {\n            yield stringifyPath(currentPath);\n        }\n\n        return;\n    }\n\n    for (const [key, value] of entries(object)) {\n        yield* deepKeysIterator(value, [...currentPath, key] as any);\n    }\n}\n\nexport function deepKeys(object: any) {\n    return [...deepKeysIterator(object)];\n}\n"],"mappings":"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","ignoreList":[]}