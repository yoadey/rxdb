{"version":3,"file":"conflicts.js","names":["getDefaultRevision","createRevision","now","flatClone","deepEqual","stripAttachmentsDataFromDocument","defaultConflictHandler","i","_context","newDocumentState","realMasterState","Promise","resolve","isEqual","documentData","resolveConflictError","state","input","forkState","conflictHandler","conflictHandlerOutput","undefined","resolvedDoc","Object","assign","_meta","_rev","_attachments","lwt","checkpointKey","output"],"sources":["../../../src/replication-protocol/conflicts.ts"],"sourcesContent":["import type {\n    RxConflictHandler,\n    RxConflictHandlerInput,\n    RxConflictHandlerOutput,\n    RxDocumentData,\n    RxStorageInstanceReplicationState\n} from '../types/index.d.ts';\nimport {\n    getDefaultRevision,\n    createRevision,\n    now,\n    flatClone,\n    deepEqual\n} from '../plugins/utils/index.ts';\nimport { stripAttachmentsDataFromDocument } from '../rx-storage-helper.ts';\n\nexport const defaultConflictHandler: RxConflictHandler<any> = function (\n    i: RxConflictHandlerInput<any>,\n    _context: string\n): Promise<RxConflictHandlerOutput<any>> {\n    const newDocumentState = stripAttachmentsDataFromDocument(i.newDocumentState);\n    const realMasterState = stripAttachmentsDataFromDocument(i.realMasterState);\n\n    /**\n     * If the documents are deep equal,\n     * we have no conflict.\n     * On your custom conflict handler you might only\n     * check some properties, like the updatedAt time,\n     * for better performance, because deepEqual is expensive.\n     */\n    if (deepEqual(\n        newDocumentState,\n        realMasterState\n    )) {\n        return Promise.resolve({\n            isEqual: true\n        });\n    }\n\n    /**\n     * The default conflict handler will always\n     * drop the fork state and use the master state instead.\n     */\n    return Promise.resolve({\n        isEqual: false,\n        documentData: i.realMasterState\n    });\n};\n\n\n/**\n * Resolves a conflict error or determines that the given document states are equal.\n * Returns the resolved document that must be written to the fork.\n * Then the new document state can be pushed upstream.\n * If document is not in conflict, returns undefined.\n * If error is non-409, it throws an error.\n * Conflicts are only solved in the upstream, never in the downstream.\n */\nexport async function resolveConflictError<RxDocType>(\n    state: RxStorageInstanceReplicationState<RxDocType>,\n    input: RxConflictHandlerInput<RxDocType>,\n    forkState: RxDocumentData<RxDocType>\n): Promise<{\n    resolvedDoc: RxDocumentData<RxDocType>;\n    output: RxConflictHandlerOutput<RxDocType>;\n} | undefined> {\n    const conflictHandler: RxConflictHandler<RxDocType> = state.input.conflictHandler;\n    const conflictHandlerOutput = await conflictHandler(input, 'replication-resolve-conflict');\n\n    if (conflictHandlerOutput.isEqual) {\n        /**\n         * Documents are equal,\n         * so this is not a conflict -> do nothing.\n         */\n        return undefined;\n    } else {\n        /**\n         * We have a resolved conflict,\n         * use the resolved document data.\n         */\n        const resolvedDoc: RxDocumentData<RxDocType> = Object.assign(\n            {},\n            conflictHandlerOutput.documentData,\n            {\n                /**\n                 * Because the resolved conflict is written to the fork,\n                 * we have to keep/update the forks _meta data, not the masters.\n                 */\n                _meta: flatClone(forkState._meta),\n                _rev: getDefaultRevision(),\n                _attachments: flatClone(forkState._attachments)\n            }\n        ) as any;\n        resolvedDoc._meta.lwt = now();\n        resolvedDoc._rev = createRevision(\n            await state.checkpointKey,\n            forkState\n        );\n        return {\n            resolvedDoc,\n            output: conflictHandlerOutput\n        };\n    }\n}\n"],"mappings":"AAOA,SACIA,kBAAkB,EAClBC,cAAc,EACdC,GAAG,EACHC,SAAS,EACTC,SAAS,QACN,2BAA2B;AAClC,SAASC,gCAAgC,QAAQ,yBAAyB;AAE1E,OAAO,IAAMC,sBAA8C,GAAG,SAAAA,CAC1DC,CAA8B,EAC9BC,QAAgB,EACqB;EACrC,IAAMC,gBAAgB,GAAGJ,gCAAgC,CAACE,CAAC,CAACE,gBAAgB,CAAC;EAC7E,IAAMC,eAAe,GAAGL,gCAAgC,CAACE,CAAC,CAACG,eAAe,CAAC;;EAE3E;AACJ;AACA;AACA;AACA;AACA;AACA;EACI,IAAIN,SAAS,CACTK,gBAAgB,EAChBC,eACJ,CAAC,EAAE;IACC,OAAOC,OAAO,CAACC,OAAO,CAAC;MACnBC,OAAO,EAAE;IACb,CAAC,CAAC;EACN;;EAEA;AACJ;AACA;AACA;EACI,OAAOF,OAAO,CAACC,OAAO,CAAC;IACnBC,OAAO,EAAE,KAAK;IACdC,YAAY,EAAEP,CAAC,CAACG;EACpB,CAAC,CAAC;AACN,CAAC;;AAGD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,eAAeK,oBAAoBA,CACtCC,KAAmD,EACnDC,KAAwC,EACxCC,SAAoC,EAIzB;EACX,IAAMC,eAA6C,GAAGH,KAAK,CAACC,KAAK,CAACE,eAAe;EACjF,IAAMC,qBAAqB,GAAG,MAAMD,eAAe,CAACF,KAAK,EAAE,8BAA8B,CAAC;EAE1F,IAAIG,qBAAqB,CAACP,OAAO,EAAE;IAC/B;AACR;AACA;AACA;IACQ,OAAOQ,SAAS;EACpB,CAAC,MAAM;IACH;AACR;AACA;AACA;IACQ,IAAMC,WAAsC,GAAGC,MAAM,CAACC,MAAM,CACxD,CAAC,CAAC,EACFJ,qBAAqB,CAACN,YAAY,EAClC;MACI;AAChB;AACA;AACA;MACgBW,KAAK,EAAEtB,SAAS,CAACe,SAAS,CAACO,KAAK,CAAC;MACjCC,IAAI,EAAE1B,kBAAkB,CAAC,CAAC;MAC1B2B,YAAY,EAAExB,SAAS,CAACe,SAAS,CAACS,YAAY;IAClD,CACJ,CAAQ;IACRL,WAAW,CAACG,KAAK,CAACG,GAAG,GAAG1B,GAAG,CAAC,CAAC;IAC7BoB,WAAW,CAACI,IAAI,GAAGzB,cAAc,CAC7B,MAAMe,KAAK,CAACa,aAAa,EACzBX,SACJ,CAAC;IACD,OAAO;MACHI,WAAW;MACXQ,MAAM,EAAEV;IACZ,CAAC;EACL;AACJ","ignoreList":[]}